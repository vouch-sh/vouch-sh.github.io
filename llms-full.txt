# Vouch — Complete Documentation

> Vouch is an open-source credential broker that replaces long-lived secrets (AWS keys, SSH keys, GitHub PATs, registry tokens) with short-lived credentials after FIDO2 hardware verification.

Source: https://github.com/vouch-sh/vouch
Website: https://vouch.sh

Note: Throughout this documentation, references to `us.vouch.sh` refer to the Vouch US instance URL used for OIDC discovery, credential endpoints, and API calls.



---

# Getting Started with Vouch

Source: https://vouch.sh/docs/getting-started/


Most developer credential systems rely on static secrets: SSH private keys sitting in `~/.ssh`, AWS access keys in `~/.aws/credentials`, GitHub PATs pasted into environment variables. These secrets never expire, are trivially exfiltrated by malware, and have no proof of who used them.

Vouch replaces all of them with credentials derived from a [FIDO2/WebAuthn](https://fidoalliance.org/fido2/) hardware key assertion -- every credential is short-lived, bound to a verified human identity, and logged. This guide walks you through installing the CLI, enrolling your YubiKey, and performing your first login. By the end you will have hardware-backed credentials ready for SSH, AWS, and Git.

## Prerequisites

- A **YubiKey 5 series** (or any compatible FIDO2 security key)
- A **Vouch server instance**, such as https://{{< instance-url >}}

> **Organization ownership:** The first person to log into Vouch from a Google Workspace domain automatically becomes the organization owner. The owner can configure integrations, manage team members, and connect services like GitHub and AWS for the rest of the team.

---

## Step 1 -- Install the CLI

### macOS

Install with Homebrew:

```
brew install vouch-sh/tap/vouch
```

After installing, start the Vouch background service:

```
brew services start vouch
```

### Debian / Ubuntu

```bash
# Import GPG key
curl -fsSL https://packages.vouch.sh/gpg/vouch.asc \
  | gpg --dearmor \
  | sudo tee /usr/share/keyrings/vouch-archive-keyring.gpg > /dev/null

# Add repository
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/vouch-archive-keyring.gpg] https://packages.vouch.sh/apt stable main" \
  | sudo tee /etc/apt/sources.list.d/vouch.list > /dev/null

# Install
sudo apt-get update && sudo apt-get install -y vouch
```

### Fedora / RHEL

```bash
sudo tee /etc/yum.repos.d/vouch.repo << 'EOF'
[vouch]
name=Vouch
baseurl=https://packages.vouch.sh/rpm/$basearch/
gpgcheck=1
gpgkey=https://packages.vouch.sh/gpg/vouch.asc
enabled=1
EOF

sudo dnf install -y vouch
```

### Windows

Windows support is limited. Download the latest binary from the [GitHub releases](https://github.com/vouch-sh/vouch/releases) page.

> **Note:** The SSH agent and SSH integration are not available on Windows. Only basic authentication and credential exchange commands are supported: `enroll`, `login`, `credential aws`, and `credential github`.

### Verify the installation

After installing, confirm the CLI is available:

```
vouch --version
```

---

## Step 2 -- Enroll your YubiKey

Enrollment registers your YubiKey with the Vouch server and links it to your identity. You only need to do this once per key.

```
vouch enroll --server https://{{< instance-url >}}
```

This command will:

1. Display a URL and a one-time code in your terminal (using the [RFC 8628 Device Authorization Grant](https://datatracker.ietf.org/doc/html/rfc8628) flow).
2. Open the URL in your browser (or you can navigate to it manually) and enter the one-time code.
3. Ask you to verify your identity through your organization's SSO provider.
4. Prompt you to register your YubiKey as a FIDO2 credential.
5. Set a PIN on the YubiKey if one has not been configured already.
6. Save the server configuration locally so future commands know where to authenticate.

Once enrollment completes, the CLI prints a confirmation and you are ready to log in.

---

## Step 3 -- Daily login

Each workday begins with a single `vouch login`. This authenticates you with your YubiKey and provisions short-lived credentials that last for 8 hours.

```
vouch login
Enter PIN: ****
Touch your YubiKey...
Authenticated for 8 hours
```

That is it. After login, every integration -- SSH, AWS, Git -- uses the session credentials automatically. When the 8-hour window expires, run `vouch login` again.

---

## Step 4 -- Set up integrations

Before your tools can use Vouch credentials, your organization needs to configure the relevant integrations on the Vouch server. Work with your administrator to enable the services you need:

- **[AWS Integration](/docs/aws/)** -- Federate into AWS with OIDC and assume IAM roles using short-lived STS credentials.
- **[SSH Certificates](/docs/ssh/)** -- Connect to servers using Vouch-signed SSH certificates instead of static keys.
- **[Amazon EKS](/docs/eks/)** -- Authenticate to Kubernetes clusters running on EKS.
- **[GitHub Integration](/docs/github/)** -- Access private GitHub repositories using short-lived tokens.
- **[Docker Registries](/docs/docker/)** -- Authenticate to container registries like ECR and GHCR.
- **[AWS CodeArtifact](/docs/codeartifact/)** -- Authenticate to AWS CodeArtifact package repositories.
- **[AWS CodeCommit](/docs/codecommit/)** -- Authenticate to AWS CodeCommit Git repositories.
- **[Cargo Integration](/docs/cargo/)** -- Authenticate to private Cargo registries.
- **[AWS Systems Manager Session Manager](/docs/ssm/)** -- Connect to EC2 instances through AWS Systems Manager.
- **[Database Authentication](/docs/databases/)** -- Connect to RDS, Aurora, and Redshift with IAM authentication.
- **[Infrastructure as Code](/docs/iac/)** -- Use CDK, Terraform, SAM, and other IaC tools.
- **[CI/CD Integration](/docs/cicd/)** -- Add human authorization gates to deployments.
- **[AI Model Access](/docs/bedrock/)** -- Hardware-verified access to Amazon Bedrock.

---

## Step 5 -- Use SSH, AWS, and Git

With an active session, your tools work without any extra flags or configuration:

```
# SSH just works
ssh user@server

# AWS credentials available
aws s3 ls --profile vouch
```

Vouch provides credentials on demand to each tool through the lightweight integrations configured in Step 4.

### What just started working?

One YubiKey tap gives you credentials that cascade across your entire toolchain:

| Command | Service |
|---|---|
| `ssh` | Servers (certificate auth) |
| `git push` | GitHub |
| `aws s3 ls` | AWS CLI |
| `cdk deploy` | Infrastructure as Code |
| `terraform apply` | Infrastructure as Code |
| `docker push` | ECR / GHCR |
| `helm push` | OCI Charts |
| `kubectl` | EKS |

These tools read your AWS config or Docker config -- no additional setup beyond the integrations in Step 4.

---

## Step 6 -- Onboard your team

Once you have Vouch working for yourself, bring the rest of your team onboard.

### Team enrollment

Each team member installs the CLI and enrolls with the same Vouch server. As long as they authenticate with the same Google Workspace domain, they automatically join your organization:

```bash
# Each team member runs:
brew install vouch-sh/tap/vouch
brew services start vouch
vouch enroll --server https://{{< instance-url >}}
```

No invite codes or admin approval are needed for enrollment. The first person to enroll from a domain becomes the organization owner; everyone else joins as a member.

### Manual user management

For small teams (under 15 people), manual management works well. As organization owner, you can view and manage team members through the Vouch server. When someone leaves, remove them manually to revoke their access.

### When to adopt SCIM

As your team grows, consider setting up [SCIM provisioning](/docs/scim/) to automate user lifecycle management. SCIM connects your identity provider (Google Workspace, Okta, Azure AD) to Vouch so that:

- New hires are provisioned automatically when added to your IdP.
- Departing employees are de-provisioned instantly when their IdP account is deactivated.
- You never forget to revoke someone's access.

SCIM is recommended for teams of 15+ people, but can be set up at any team size.

---

## What happens when you login

When you run `vouch login`, the following takes place behind the scenes:

1. **FIDO2 assertion** -- The CLI asks your YubiKey to sign a challenge from the Vouch server. This proves possession of the enrolled key and requires both your PIN and a physical touch.
2. **Identity verification** -- The server validates the signed assertion against the public key stored during enrollment.
3. **Credential issuance** -- On success, the server issues a session token and an **SSH certificate** signed by the Vouch CA, valid for 8 hours.
4. **On-demand credentials** -- AWS, Git, Docker, Cargo, and other credentials are obtained on-demand by their respective credential helpers when you use those tools. Each helper exchanges your active session for a short-lived, service-specific credential.
5. **Local caching** -- The CLI stores the session and SSH certificate in memory (via the Vouch agent) so subsequent commands can use them without additional YubiKey interaction.

Because every credential is short-lived and bound to a hardware key, there are no long-lived secrets on disk that can be stolen or leaked.





---

# Replace AWS Access Keys with Short-Lived Credentials

Source: https://vouch.sh/docs/aws/


If your team distributes AWS access keys through `~/.aws/credentials`, you have credentials that never expire, are trivially exfiltrated by malware, and leave no trace of who used them. Rotating keys is a manual chore that rarely happens on schedule, and a single compromised laptop exposes keys that work indefinitely.

Vouch eliminates static access keys entirely. You configure AWS to trust Vouch as an OIDC identity provider, and developers get temporary STS credentials -- valid for up to 1 hour -- after authenticating with their YubiKey. Every API call is tied to a verified human identity in CloudTrail. There are no keys to rotate, no credentials on disk, and no shared secrets.

## How Vouch compares to `aws login` and `aws sso login`

AWS provides two built-in CLI authentication commands. Here is how they compare to Vouch:

- **[`aws login`](https://docs.aws.amazon.com/signin/latest/userguide/command-line-sign-in.html#command-line-sign-in-local-development)** -- New in AWS CLI v2.32+. Opens a browser to authenticate with your AWS Console credentials (IAM user, root, or federated identity) and issues temporary credentials for up to 12 hours. It requires the `SignInLocalDevelopmentAccess` managed policy and only covers AWS -- it does not provide credentials for SSH, GitHub, Docker registries, or other services.

- **[`aws sso login`](https://docs.aws.amazon.com/signin/latest/userguide/command-line-sign-in.html#command-line-sign-in-sso)** -- Authenticates through AWS IAM Identity Center (formerly AWS SSO). It requires an Identity Center instance and an SSO-configured profile (`aws configure sso`). Like `aws login`, it only covers AWS services.

- **`vouch login`** -- Authenticates with a FIDO2 hardware key (YubiKey) and provides credentials for AWS, SSH, GitHub, Docker registries, Cargo registries, AWS CodeCommit, AWS CodeArtifact, databases, and any OIDC-compatible application -- all from a single session. Every credential is tied to a hardware-verified human identity, and authentication is phishing-resistant by design.

| | `aws login` | `aws sso login` | `vouch login` |
|---|---|---|---|
| **Authentication** | Browser + console credentials | Browser + Identity Center | YubiKey tap (FIDO2) |
| **Phishing-resistant** | Depends on IdP | Depends on IdP | Yes (hardware-bound) |
| **AWS credentials** | Yes (up to 12h) | Yes | Yes (up to 1h) |
| **SSH, GitHub, Docker, etc.** | No | No | Yes |
| **Identity in CloudTrail** | IAM user or role | SSO user | Hardware-verified user |
| **Requires AWS-managed service** | No | IAM Identity Center | No |

If you already use IAM Identity Center, `aws sso login` may cover your AWS needs. Vouch is a better fit when you want a single authentication event to cover AWS and everything else your team uses, with the guarantee that every credential traces back to a physical hardware key.

## How it works

1. The developer runs `vouch login` and authenticates with their YubiKey.
2. The Vouch server issues a short-lived **OIDC ID token** signed with **ES256** (ECDSA over P-256). The token contains claims such as `sub` (user ID) and `email`.
3. When the developer runs an AWS command (or `vouch credential aws`), the CLI calls **AWS STS AssumeRoleWithWebIdentity**, presenting the ID token.
4. AWS validates the token signature against the Vouch server's JWKS endpoint, checks the audience and issuer, and returns temporary credentials (access key, secret key, session token) valid for up to 1 hour.
5. The developer's AWS CLI, SDK, or Terraform session uses these credentials transparently.

Because the ID token is scoped to the authenticated user and is short-lived, credentials cannot be shared or reused after expiry.

---

## Step 1 -- Create the OIDC Provider in AWS (admin)

Before any user can assume a role, an administrator must register the Vouch server as an OIDC identity provider in the target AWS account.

### AWS CLI

> For background on OIDC identity providers in AWS, see [Creating OpenID Connect (OIDC) identity providers](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc.html) in the AWS documentation.

```bash
aws iam create-open-id-connect-provider \
  --url "https://{{< instance-url >}}" \
  --client-id-list "https://{{< instance-url >}}"
```

> **Note:** AWS fetches the JWKS from `https://{{< instance-url >}}/.well-known/jwks.json` at runtime to verify token signatures. A `ThumbprintList` is no longer required -- AWS obtains the root CA thumbprint automatically.

### CloudFormation

```yaml
AWSTemplateFormatVersion: "2010-09-09"
Description: Vouch OIDC Identity Provider

Resources:
  VouchOIDCProvider:
    Type: "AWS::IAM::OIDCProvider"
    Properties:
      Url: "https://{{< instance-url >}}"
      ClientIdList:
        - "https://{{< instance-url >}}"
```

### Terraform

```hcl
resource "aws_iam_openid_connect_provider" "vouch" {
  url            = "https://{{< instance-url >}}"
  client_id_list = ["https://{{< instance-url >}}"]
}
```

---

## Step 2 -- Create an IAM Role (admin)

Create an IAM role that developers will assume. The trust policy must allow [`AssumeRoleWithWebIdentity`](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html) from the Vouch OIDC provider.

### AWS CLI

```bash
ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

cat > /tmp/vouch-trust-policy.json << EOF
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Federated": "arn:aws:iam::${ACCOUNT_ID}:oidc-provider/{{< instance-url >}}"
      },
      "Action": "sts:AssumeRoleWithWebIdentity",
      "Condition": {
        "StringEquals": {
          "{{< instance-url >}}:aud": "{{< instance-url >}}"
        }
      }
    }
  ]
}
EOF

aws iam create-role \
  --role-name VouchDeveloper \
  --assume-role-policy-document file:///tmp/vouch-trust-policy.json

# Attach a permissions policy (example: read-only access)
aws iam attach-role-policy \
  --role-name VouchDeveloper \
  --policy-arn arn:aws:iam::aws:policy/ReadOnlyAccess
```

### CloudFormation

```yaml
Resources:
  VouchDeveloperRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: VouchDeveloper
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Federated: !Sub "arn:aws:iam::${AWS::AccountId}:oidc-provider/{{< instance-url >}}"
            Action: "sts:AssumeRoleWithWebIdentity"
            Condition:
              StringEquals:
                "{{< instance-url >}}:aud": "{{< instance-url >}}"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/ReadOnlyAccess
```

### Terraform

```hcl
data "aws_caller_identity" "current" {}

resource "aws_iam_role" "vouch_developer" {
  name = "VouchDeveloper"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Federated = "arn:aws:iam::${data.aws_caller_identity.current.account_id}:oidc-provider/{{< instance-url >}}"
        }
        Action = "sts:AssumeRoleWithWebIdentity"
        Condition = {
          StringEquals = {
            "{{< instance-url >}}:aud" = "{{< instance-url >}}"
          }
        }
      }
    ]
  })
}

resource "aws_iam_role_policy_attachment" "vouch_developer_readonly" {
  role       = aws_iam_role.vouch_developer.name
  policy_arn = "arn:aws:iam::aws:policy/ReadOnlyAccess"
}
```

---

## Tips for restricting access

### Restrict by email address

Limit role assumption to specific users by adding an email condition to the trust policy:

```json
"Condition": {
  "StringEquals": {
    "{{< instance-url >}}:aud": "{{< instance-url >}}",
    "{{< instance-url >}}:sub": "user@example.com"
  }
}
```

### Restrict by email domain

Allow any user from a specific domain:

```json
"Condition": {
  "StringEquals": {
    "{{< instance-url >}}:aud": "{{< instance-url >}}"
  },
  "StringLike": {
    "{{< instance-url >}}:sub": "*@example.com"
  }
}
```

### Session tags

Vouch sets the following session tags when assuming a role, which you can use in IAM policies for [attribute-based access control (ABAC)](https://docs.aws.amazon.com/IAM/latest/UserGuide/introduction_attribute-based-access-control.html):

| Tag Key | Value | Example |
|---------|-------|---------|
| `email` | The user's verified email | `alice@example.com` |
| `domain` | The user's organization domain (from the OIDC `hd` claim) | `example.com` |

You can reference these tags in IAM policy conditions using `aws:PrincipalTag`:

```json
{
  "Condition": {
    "StringEquals": {
      "aws:PrincipalTag/domain": "example.com"
    }
  }
}
```

---

## Step 3 -- Configure the Vouch CLI

Each developer needs to tell the CLI which IAM role to assume and in which AWS profile to store the credentials. Run:

```bash
vouch setup aws --role arn:aws:iam::123456789012:role/VouchDeveloper
```

This command accepts the following flags:

- `--role` -- The ARN of the IAM role created in Step 2 (required).
- `--profile` -- The AWS profile name to write credentials to (default: `vouch`; additional profiles auto-name as `vouch-2`, `vouch-3`, etc.).

The command writes a `credential_process` entry into `~/.aws/config` so that the AWS CLI and SDKs automatically call `vouch credential aws` whenever credentials are needed:

```ini
[profile vouch]
credential_process = vouch credential aws --role arn:aws:iam::123456789012:role/VouchDeveloper
```

> **Note:** If you need a specific region for this profile, add a `region` line manually (e.g., `region = us-east-1`).

After setup, any tool that reads AWS profiles will transparently use Vouch credentials.

---

## Step 4 -- Test

Verify that everything is working:

```bash
# Make sure you are logged in
vouch login

# Check your identity
aws sts get-caller-identity --profile vouch
```

You should see output similar to:

```json
{
  "UserId": "AROA...:alice@example.com",
  "Account": "123456789012",
  "Arn": "arn:aws:sts::123456789012:assumed-role/VouchDeveloper/alice@example.com"
}
```

Try running a command against a real AWS service:

```bash
aws s3 ls --profile vouch
```

---

## Troubleshooting

### "Not authorized to perform sts:AssumeRoleWithWebIdentity"

- Verify the OIDC provider URL in the IAM trust policy matches `https://{{< instance-url >}}` exactly (no trailing slash).
- Confirm the `aud` condition matches the client ID registered with the OIDC provider.

### "Token is expired"

- Run `vouch login` again to refresh your session. OIDC tokens are short-lived by design.

### "Invalid identity token"

- Ensure the OIDC provider in AWS points to the correct Vouch server URL: `https://{{< instance-url >}}`.
- Verify that the Vouch server's JWKS endpoint (`https://{{< instance-url >}}/.well-known/jwks.json`) is reachable from the internet (AWS must be able to fetch it).

### Credentials not appearing in the expected profile

- Run `vouch setup aws` again and verify the profile name.
- Check `~/.aws/config` for conflicting profile definitions.

### Permission errors after assuming the role

- The trust policy controls who can assume the role; the permissions policy controls what they can do. Verify the correct permissions policies are attached to the IAM role.



---

# Multi-Account AWS Strategy

Source: https://vouch.sh/docs/aws-multi-account/


Most startups outgrow a single AWS account quickly. By the time you have a dev and production environment, you have two accounts. Add staging, a shared services account for CI/CD, and a logging account, and you have five. Each account needs an OIDC provider and IAM roles that trust Vouch.

This guide covers deploying Vouch OIDC federation across an AWS Organization using CloudFormation StackSets, Terraform modules, and SCPs to enforce that only Vouch can federate into your accounts.

---

## Architecture

```
AWS Organization (Management Account)
├── Shared Services (CI/CD, logging)
├── Development
├── Staging
└── Production

Each account gets:
  ├── OIDC Provider (trusting us.vouch.sh)
  └── IAM Roles (VouchDeveloper, VouchReadOnly, etc.)
```

Every developer uses the same `vouch login` session. The AWS profile they select determines which account and role they assume.

---

## Option 1 -- CloudFormation StackSets

StackSets deploy a CloudFormation template across all accounts in an AWS Organization (or a subset).

### Template

```yaml
AWSTemplateFormatVersion: "2010-09-09"
Description: "Vouch OIDC federation (deployed via StackSet)"

Parameters:
  VouchServerUrl:
    Type: String
    Default: "{{< instance-url >}}"

  RoleName:
    Type: String
    Default: "VouchDeveloper"

  ManagedPolicyArn:
    Type: String
    Default: "arn:aws:iam::aws:policy/ReadOnlyAccess"
    Description: "Permissions policy to attach to the role"

Resources:
  VouchOIDCProvider:
    Type: AWS::IAM::OIDCProvider
    Properties:
      Url: !Sub "https://${VouchServerUrl}"
      ClientIdList:
        - !Sub "https://${VouchServerUrl}"

  VouchRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Ref RoleName
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Federated: !Sub "arn:aws:iam::${AWS::AccountId}:oidc-provider/${VouchServerUrl}"
            Action: "sts:AssumeRoleWithWebIdentity"
            Condition:
              StringEquals:
                !Sub "${VouchServerUrl}:aud": !Sub "https://${VouchServerUrl}"
      ManagedPolicyArns:
        - !Ref ManagedPolicyArn

Outputs:
  RoleArn:
    Value: !GetAtt VouchRole.Arn
```

### Deploy to all accounts

From the management account:

```bash
aws cloudformation create-stack-set \
  --stack-set-name vouch-federation \
  --template-body file://vouch-stackset.yaml \
  --capabilities CAPABILITY_NAMED_IAM \
  --permission-model SERVICE_MANAGED \
  --auto-deployment Enabled=true,RetainStacksOnAccountRemoval=false

aws cloudformation create-stack-instances \
  --stack-set-name vouch-federation \
  --deployment-targets OrganizationalUnitIds=ou-xxxx-xxxxxxxx \
  --regions us-east-1
```

With `--auto-deployment Enabled`, new accounts added to the OU automatically receive the Vouch OIDC provider and IAM role.

### Per-account role customization

Use different parameter overrides per account to control permissions:

```bash
# Development: PowerUserAccess
aws cloudformation create-stack-instances \
  --stack-set-name vouch-federation \
  --accounts 111111111111 \
  --regions us-east-1 \
  --parameter-overrides ParameterKey=ManagedPolicyArn,ParameterValue=arn:aws:iam::aws:policy/PowerUserAccess ParameterKey=RoleName,ParameterValue=VouchDeveloper

# Production: ReadOnlyAccess
aws cloudformation create-stack-instances \
  --stack-set-name vouch-federation \
  --accounts 222222222222 \
  --regions us-east-1 \
  --parameter-overrides ParameterKey=ManagedPolicyArn,ParameterValue=arn:aws:iam::aws:policy/ReadOnlyAccess ParameterKey=RoleName,ParameterValue=VouchReadOnly
```

---

## Option 2 -- Terraform

### Module

Create a reusable Terraform module:

```hcl
# modules/vouch-federation/main.tf

variable "vouch_server_url" {
  type    = string
  default = "{{< instance-url >}}"
}

variable "role_name" {
  type    = string
  default = "VouchDeveloper"
}

variable "policy_arns" {
  type    = list(string)
  default = ["arn:aws:iam::aws:policy/ReadOnlyAccess"]
}

data "aws_caller_identity" "current" {}

resource "aws_iam_openid_connect_provider" "vouch" {
  url            = "https://${var.vouch_server_url}"
  client_id_list = ["https://${var.vouch_server_url}"]
}

resource "aws_iam_role" "vouch" {
  name = var.role_name

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Federated = "arn:aws:iam::${data.aws_caller_identity.current.account_id}:oidc-provider/${var.vouch_server_url}"
        }
        Action = "sts:AssumeRoleWithWebIdentity"
        Condition = {
          StringEquals = {
            "${var.vouch_server_url}:aud" = "https://${var.vouch_server_url}"
          }
        }
      }
    ]
  })
}

resource "aws_iam_role_policy_attachment" "vouch" {
  count      = length(var.policy_arns)
  role       = aws_iam_role.vouch.name
  policy_arn = var.policy_arns[count.index]
}

output "role_arn" {
  value = aws_iam_role.vouch.arn
}
```

### Usage per account

```hcl
# environments/dev/main.tf
module "vouch" {
  source      = "../../modules/vouch-federation"
  role_name   = "VouchDeveloper"
  policy_arns = ["arn:aws:iam::aws:policy/PowerUserAccess"]
}

# environments/prod/main.tf
module "vouch" {
  source      = "../../modules/vouch-federation"
  role_name   = "VouchReadOnly"
  policy_arns = ["arn:aws:iam::aws:policy/ReadOnlyAccess"]
}
```

---

## Restricting federation with SCPs

Use [Service Control Policies](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_policies_scps.html) to ensure that only the Vouch OIDC provider can federate into your accounts. This prevents anyone from registering a rogue OIDC provider:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "DenyNonVouchOIDCProviders",
      "Effect": "Deny",
      "Action": [
        "iam:CreateOpenIDConnectProvider",
        "iam:DeleteOpenIDConnectProvider"
      ],
      "Resource": "*",
      "Condition": {
        "StringNotEquals": {
          "aws:PrincipalOrgID": "${aws:PrincipalOrgID}"
        }
      }
    }
  ]
}
```

> **Note:** Adjust this SCP to allow your management account or deployment pipeline to manage OIDC providers. The goal is to prevent individual developers from creating unauthorized OIDC providers in member accounts.

---

## Developer setup

Each developer configures a named AWS profile for each account:

```bash
# Development account
vouch setup aws \
  --role arn:aws:iam::111111111111:role/VouchDeveloper \
  --profile vouch-dev

# Staging account
vouch setup aws \
  --role arn:aws:iam::333333333333:role/VouchDeveloper \
  --profile vouch-staging

# Production account (read-only)
vouch setup aws \
  --role arn:aws:iam::222222222222:role/VouchReadOnly \
  --profile vouch-prod
```

This produces the following `~/.aws/config`:

```ini
[profile vouch-dev]
credential_process = vouch credential aws --role arn:aws:iam::111111111111:role/VouchDeveloper

[profile vouch-staging]
credential_process = vouch credential aws --role arn:aws:iam::333333333333:role/VouchDeveloper

[profile vouch-prod]
credential_process = vouch credential aws --role arn:aws:iam::222222222222:role/VouchReadOnly
```

Use profiles per command:

```bash
# Deploy to dev
cdk deploy --profile vouch-dev

# Check production (read-only)
aws s3 ls --profile vouch-prod
```

Or set a default:

```bash
export AWS_PROFILE=vouch-dev
```

---

## Role design patterns

### By environment

| Account | Role | Policy | Who |
|---|---|---|---|
| Development | `VouchDeveloper` | `PowerUserAccess` | All developers |
| Staging | `VouchDeveloper` | `PowerUserAccess` | All developers |
| Production | `VouchReadOnly` | `ReadOnlyAccess` | All developers |
| Production | `VouchDeployer` | Custom deploy policy | Senior engineers only |

### Restricting production access by email

Add an email condition to the production deployer role's trust policy:

```json
"Condition": {
  "StringEquals": {
    "{{< instance-url >}}:aud": "https://{{< instance-url >}}",
    "{{< instance-url >}}:sub": [
      "alice@example.com",
      "bob@example.com"
    ]
  }
}
```

Only Alice and Bob can assume the `VouchDeployer` role. Everyone else can still assume `VouchReadOnly`.

---

## Troubleshooting

### "OIDC provider already exists"

The OIDC provider URL must be unique per account. If you already created one manually, the StackSet deployment will fail for that account. Either import the existing resource or delete it before deploying.

### Credentials for the wrong account

If `aws sts get-caller-identity` shows an unexpected account, verify you are using the correct profile:

```bash
aws sts get-caller-identity --profile vouch-dev
```

Check `~/.aws/config` for the correct role ARN in each profile.



---

# Replace SSH Keys with Short-Lived Certificates

Source: https://vouch.sh/docs/ssh/


Managing SSH access with traditional public keys is one of the most painful parts of growing a team. Every new hire means copying keys to every server. Every departure means hunting down and removing keys you hope you can find. Keys never expire, and there is no way to know who used them.

Vouch eliminates this entirely. Administrators trust a single certificate authority (CA) key, and developers receive short-lived SSH certificates that expire after 8 hours. There is no key distribution, no `authorized_keys` sprawl, and no offboarding checklist. Developers authenticate with `vouch login` and then `ssh` into any trusted server without passwords or key copying.

## How it works

1. During `vouch login`, the Vouch server signs the developer's ephemeral public key with an **Ed25519 CA** key.
2. The resulting SSH certificate is valid for **8 hours** and contains the developer's **email address** and **username** as principals.
3. When the developer connects to a server, the SSH client presents the certificate.
4. The server verifies the certificate was signed by the trusted CA and that one of the certificate's principals matches an allowed user.
5. The connection is established without any `authorized_keys` lookup.

Because certificates expire after 8 hours, a compromised certificate is useless the next day. There is nothing to revoke and nothing to rotate.

---

## Step 1 -- Set up the CLI (for developers)

After completing the [Getting Started](/docs/getting-started/) guide, enable the SSH agent integration:

```bash
vouch setup ssh
```

This command configures your local SSH client to use the Vouch agent for certificate authentication. It adds the following to your `~/.ssh/config`:

```
Host *
  IdentityAgent ~/.vouch/ssh-agent.sock
```

After setup, every `ssh` connection will automatically use your Vouch certificate when available, falling back to regular keys if needed.

### Verify the agent is running

```bash
vouch status
```

Look for the SSH agent line in the output. If the agent is not running, `vouch login` will start it automatically.

### Check your certificate

After logging in, inspect the current certificate:

```bash
vouch credential ssh
```

This obtains a certificate from the server and displays the certificate's principals, validity period, and signing CA.

---

## Step 2 -- Configure SSH servers (for administrators)

To accept Vouch certificates, each server must trust the Vouch CA public key. Below are three approaches for deploying this configuration.

### Fetch the CA public key

First, retrieve your organization's CA public key from the Vouch server:

```bash
curl -s https://{{< instance-url >}}/ssh/ca.pub
```

Save the output -- you will need it for each method below.

---

### CLI (manual)

On each server, add the CA public key and configure `sshd`:

```bash
# Write the CA public key
echo "CONTENTS_OF_CA_PUB" | sudo tee /etc/ssh/vouch_ca.pub

# Tell sshd to trust certificates signed by this CA
# See: https://man.openbsd.org/sshd_config#TrustedUserCAKeys
echo "TrustedUserCAKeys /etc/ssh/vouch_ca.pub" | sudo tee -a /etc/ssh/sshd_config

# Optionally set AuthorizedPrincipalsFile to control which principals are allowed
# See: https://man.openbsd.org/sshd_config#AuthorizedPrincipalsFile
echo "AuthorizedPrincipalsFile /etc/ssh/auth_principals/%u" | sudo tee -a /etc/ssh/sshd_config

# Create a principals file for a specific user
sudo mkdir -p /etc/ssh/auth_principals
echo "alice@example.com" | sudo tee /etc/ssh/auth_principals/alice

# Restart sshd
sudo systemctl restart sshd
```

---

### Ansible

```yaml
- name: Configure Vouch SSH CA trust
  hosts: all
  become: true
  vars:
    vouch_ca_pub: "{{ lookup('url', 'https://{{< instance-url >}}/ssh/ca.pub') }}"

  tasks:
    - name: Write Vouch CA public key
      copy:
        content: "{{ vouch_ca_pub }}"
        dest: /etc/ssh/vouch_ca.pub
        owner: root
        group: root
        mode: "0644"

    - name: Trust Vouch CA for user certificates
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "^TrustedUserCAKeys"
        line: "TrustedUserCAKeys /etc/ssh/vouch_ca.pub"
      notify: restart sshd

    - name: Set AuthorizedPrincipalsFile
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "^AuthorizedPrincipalsFile"
        line: "AuthorizedPrincipalsFile /etc/ssh/auth_principals/%u"
      notify: restart sshd

    - name: Create auth_principals directory
      file:
        path: /etc/ssh/auth_principals
        state: directory
        owner: root
        group: root
        mode: "0755"

  handlers:
    - name: restart sshd
      service:
        name: sshd
        state: restarted
```

---

### Terraform (AWS EC2 user data)

```hcl
resource "aws_instance" "example" {
  ami           = "ami-0abcdef1234567890"
  instance_type = "t3.micro"

  user_data = <<-EOF
    #!/bin/bash
    set -e

    # Fetch and install the Vouch CA public key
    curl -s https://{{< instance-url >}}/ssh/ca.pub \
      | tee /etc/ssh/vouch_ca.pub

    # Configure sshd to trust the CA
    echo "TrustedUserCAKeys /etc/ssh/vouch_ca.pub" >> /etc/ssh/sshd_config
    echo "AuthorizedPrincipalsFile /etc/ssh/auth_principals/%u" >> /etc/ssh/sshd_config

    mkdir -p /etc/ssh/auth_principals

    systemctl restart sshd
  EOF

  tags = {
    Name = "vouch-ssh-example"
  }
}
```

---

## Tip: understanding principals

Vouch certificates include two principals by default:

| Principal | Example | Use case |
|-----------|---------|----------|
| Email address | `alice@example.com` | Unique per-user access control |
| Username | `alice` | Matches standard Unix usernames |

When configuring `AuthorizedPrincipalsFile`, you can list either the email or the username (or both) in the principals file for each Unix account.

**Example:** To allow both `alice@example.com` and `bob@example.com` to SSH as the `deploy` user:

```bash
sudo mkdir -p /etc/ssh/auth_principals
printf "alice@example.com\nbob@example.com\n" | sudo tee /etc/ssh/auth_principals/deploy
```

If you do not configure `AuthorizedPrincipalsFile`, OpenSSH will accept any certificate signed by the trusted CA. This is convenient for testing but is not recommended for production.

---

## Step 3 -- Test the connection

From a developer machine with an active Vouch session:

```bash
# Log in if you have not already
vouch login

# Connect to a configured server
ssh alice@server.example.com
```

The connection should succeed without prompting for a password or key passphrase. To verify that certificate authentication was used, check the server's auth log:

```bash
# On the server
sudo grep "Accepted certificate" /var/log/auth.log
```

You should see an entry like:

```
Accepted publickey for alice from 192.168.1.100 port 54321 ssh2: ED25519-CERT SHA256:... ID "alice@example.com" serial 42 CA ED25519 SHA256:...
```

---

## How certificate authentication works

Here is the full flow in detail:

1. **Login** -- The developer runs `vouch login`, authenticates with their YubiKey (PIN + touch), and receives a signed SSH certificate from the Vouch server's Ed25519 CA.

2. **Connection** -- The developer runs `ssh user@server`. The SSH client, configured to use the Vouch agent, presents the certificate to the server.

3. **CA verification** -- The server checks that the certificate is signed by a CA listed in `TrustedUserCAKeys`. If the signature is invalid or the CA is not trusted, the connection is rejected.

4. **Principal matching** -- The server checks whether any principal in the certificate matches an entry in the `AuthorizedPrincipalsFile` for the target Unix user. If no principals file is configured, any valid certificate is accepted.

5. **Session established** -- If both checks pass, the SSH session is established. The certificate's validity period (8 hours from login) is enforced -- expired certificates are rejected at step 3.

---

## Troubleshooting

### "Permission denied (publickey)"

- Confirm you have an active Vouch session: run `vouch status`.
- Verify the Vouch agent is running and `~/.ssh/config` includes the `IdentityAgent` line.
- Check that the server has `TrustedUserCAKeys` pointing to the correct CA public key.
- If using `AuthorizedPrincipalsFile`, verify that the file for the target user contains one of the certificate's principals (email or username).

### "Certificate has expired"

- SSH certificates issued by Vouch are valid for 8 hours. Run `vouch login` to get a fresh certificate.

### Agent not found

- Run `vouch login` to start the agent, or restart it with `vouch setup ssh`.
- Verify the socket path exists: `ls -la ~/.vouch/ssh-agent.sock`.

### Server rejects the certificate even though it was signed by the right CA

- Check `AuthorizedPrincipalsFile` permissions. The file and its parent directory must be owned by root and not writable by group or others.
- Ensure the principals file is in the correct location (`/etc/ssh/auth_principals/<username>`).
- Review `/var/log/auth.log` (or `/var/log/secure` on RHEL-based systems) for detailed error messages.

### Connection falls back to password authentication

- The server may not have `TrustedUserCAKeys` configured, or `sshd` may not have been restarted after the configuration change.
- Run `ssh -v user@server` to see which authentication methods are attempted. Look for `Offering public key: ... ED25519-CERT` in the debug output.

---

## IDE Remote Development

Because Vouch configures `~/.ssh/config` with its agent, tools that build on top of SSH work automatically:

- **VS Code Remote-SSH** -- Open remote folders and terminals on any server trusted by the Vouch CA. No additional extension configuration is needed.
- **JetBrains Gateway** -- Connect to remote development environments using the same SSH certificate.
- **scp / rsync / sftp** -- File transfers use the Vouch SSH agent transparently.

As long as the Vouch agent is running and you have an active session, any tool that uses the system SSH client will authenticate with your Vouch certificate.



---

# Authenticate to Amazon EKS without Static Credentials

Source: https://vouch.sh/docs/eks/


Managing Kubernetes access with ConfigMap-based `aws-auth` entries is error-prone and hard to audit. Who has access? When was it granted? Long-lived kubeconfig tokens get shared across machines, and revoking access means editing a ConfigMap by hand.

EKS Access Entries provide a cleaner model: IAM principals map directly to Kubernetes permissions, and every authentication event is recorded in CloudTrail. Combined with Vouch, every `kubectl` command traces back to a hardware-verified human identity -- no static tokens, no shared kubeconfigs.

## How it works

The authentication flow chains four components:

```
vouch login --> vouch credential aws --> aws eks get-token --> kubectl
```

1. **`vouch login`** -- The developer authenticates with their YubiKey and receives an OIDC ID token from the Vouch server.
2. **`vouch credential aws`** -- The CLI exchanges the OIDC token for temporary AWS STS credentials by calling `AssumeRoleWithWebIdentity`.
3. **`aws eks get-token`** -- The AWS CLI (or SDK) uses the STS credentials to generate a short-lived Kubernetes authentication token for the target EKS cluster.
4. **`kubectl`** -- The Kubernetes client sends the token to the EKS API server, which validates it against IAM and applies the permissions defined by Access Entries or RBAC.

Because every step uses short-lived credentials, there are no static kubeconfig tokens or long-lived AWS keys to manage.

---

## Prerequisites

Before setting up EKS authentication with Vouch, ensure you have:

- **Vouch CLI installed and enrolled** -- Complete the [Getting Started](/docs/getting-started/) guide.
- **AWS integration configured** -- Complete the [AWS Integration](/docs/aws/) guide. You need a working `vouch credential aws` setup with an IAM role.
- **AWS CLI v2** installed (`aws --version`).
- **kubectl** installed (`kubectl version --client`).
- **An EKS cluster** with the API server authentication mode set to include `API` (either `API` or `API_AND_CONFIG_MAP`). Clusters created with the default `CONFIG_MAP` mode must be updated.

> See [EKS cluster authentication modes](https://docs.aws.amazon.com/eks/latest/userguide/cluster-auth.html) for details on switching to API mode, and [EKS Access Entries](https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html) for the Access Entries feature.

---

## Setup

Configure `kubectl` to use your Vouch-backed AWS credentials for cluster authentication:

```bash
aws eks update-kubeconfig \
  --name YOUR_CLUSTER_NAME \
  --region YOUR_REGION \
  --profile vouch
```

This writes or updates `~/.kube/config` with an `exec`-based user entry that calls `aws eks get-token`. Since the `vouch` AWS profile is configured with `credential_process`, the full chain from YubiKey to Kubernetes is automatic.

### Verify the kubeconfig

Check that the context is set correctly:

```bash
kubectl config current-context
```

The output should include the cluster name and region.

---

## Usage

With everything configured, daily usage is straightforward:

```bash
# Start your day
vouch login

# Use kubectl as normal
kubectl get pods
kubectl get namespaces
kubectl logs deployment/my-app
```

All authentication happens transparently. If your session expires (after 8 hours), run `vouch login` again.

---

## Creating EKS Access Entries

EKS Access Entries map IAM principals (users or roles) to Kubernetes permissions. An administrator must create an Access Entry for the IAM role used by Vouch.

### AWS CLI

```bash
# Create the Access Entry for the Vouch IAM role
aws eks create-access-entry \
  --cluster-name YOUR_CLUSTER_NAME \
  --principal-arn arn:aws:iam::123456789012:role/VouchDeveloper \
  --type STANDARD

# Associate an access policy (e.g., cluster admin)
aws eks associate-access-policy \
  --cluster-name YOUR_CLUSTER_NAME \
  --principal-arn arn:aws:iam::123456789012:role/VouchDeveloper \
  --policy-arn arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy \
  --access-scope '{"type": "cluster"}'
```

To restrict access to specific namespaces:

```bash
aws eks associate-access-policy \
  --cluster-name YOUR_CLUSTER_NAME \
  --principal-arn arn:aws:iam::123456789012:role/VouchDeveloper \
  --policy-arn arn:aws:eks::aws:cluster-access-policy/AmazonEKSEditPolicy \
  --access-scope '{"type": "namespace", "namespaces": ["default", "staging"]}'
```

### Terraform

```hcl
resource "aws_eks_access_entry" "vouch_developer" {
  cluster_name  = aws_eks_cluster.main.name
  principal_arn = aws_iam_role.vouch_developer.arn
  type          = "STANDARD"
}

resource "aws_eks_access_policy_association" "vouch_developer_admin" {
  cluster_name  = aws_eks_cluster.main.name
  principal_arn = aws_iam_role.vouch_developer.arn
  policy_arn    = "arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy"

  access_scope {
    type = "cluster"
  }
}
```

For namespace-scoped access:

```hcl
resource "aws_eks_access_policy_association" "vouch_developer_edit" {
  cluster_name  = aws_eks_cluster.main.name
  principal_arn = aws_iam_role.vouch_developer.arn
  policy_arn    = "arn:aws:eks::aws:cluster-access-policy/AmazonEKSEditPolicy"

  access_scope {
    type       = "namespace"
    namespaces = ["default", "staging"]
  }
}
```

---

## Available Access Policies

EKS provides several built-in [access policies](https://docs.aws.amazon.com/eks/latest/userguide/access-policies.html) that map to standard Kubernetes RBAC roles:

| Access Policy ARN | Kubernetes Equivalent | Description |
|---|---|---|
| `arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy` | `cluster-admin` | Full access to all resources in the cluster. |
| `arn:aws:eks::aws:cluster-access-policy/AmazonEKSAdminPolicy` | `admin` | Full access within namespaces, plus limited cluster-scoped access. |
| `arn:aws:eks::aws:cluster-access-policy/AmazonEKSEditPolicy` | `edit` | Read/write access to most resources in a namespace (no role or role-binding changes). |
| `arn:aws:eks::aws:cluster-access-policy/AmazonEKSViewPolicy` | `view` | Read-only access to most resources in a namespace. |
| `arn:aws:eks::aws:cluster-access-policy/AmazonEKSAdminViewPolicy` | N/A | Read-only access to all resources in the cluster, including secrets. |

When associating a policy, choose the appropriate **access scope**:

- **`cluster`** -- The policy applies across all namespaces.
- **`namespace`** -- The policy applies only to the specified namespaces.

Cluster-scoped policies (like `AmazonEKSClusterAdminPolicy`) must use `type: cluster`. Namespace-scoped policies (like `AmazonEKSEditPolicy`) can use either scope type.

---

## Custom RBAC

If the built-in access policies do not fit your needs, you can use standard Kubernetes RBAC instead. Create the Access Entry with type `STANDARD` and do not associate any EKS access policies. Then create Kubernetes `ClusterRoleBinding` or `RoleBinding` resources that reference the IAM role's assumed-role ARN.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vouch-developer-custom
subjects:
  - kind: Group
    name: "arn:aws:iam::123456789012:role/VouchDeveloper"
    apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: your-custom-role
  apiGroup: rbac.authorization.k8s.io
```

For per-user permissions using session tags from Vouch, you can create separate IAM roles per team or per access level and map each to different Kubernetes roles.

---

## Troubleshooting

### "error: You must be logged in to the server (Unauthorized)"

- Confirm you have an active Vouch session: `vouch status`.
- Verify AWS credentials are working: `aws sts get-caller-identity --profile vouch`.
- Check that an EKS Access Entry exists for your IAM role: `aws eks list-access-entries --cluster-name YOUR_CLUSTER_NAME`.
- Ensure the cluster's authentication mode includes `API`. Check with: `aws eks describe-cluster --name YOUR_CLUSTER_NAME --query "cluster.accessConfig.authenticationMode"`.

### "error: exec plugin is configured to use API version client.authentication.k8s.io/v1alpha1"

- Update your kubeconfig by re-running `aws eks update-kubeconfig`. Older versions of the AWS CLI may generate kubeconfig entries using a deprecated API version.
- Ensure you are running AWS CLI v2.

### Credentials expire during long operations

- STS credentials obtained through Vouch last up to 1 hour. For long-running operations such as Helm deployments or large-scale rollouts, run `vouch login` beforehand to ensure a fresh 8-hour session.
- If a command fails mid-operation, run `vouch login` and retry. The kubeconfig exec plugin will automatically pick up the new credentials.

### "AccessDeniedException" when calling EKS APIs

- The IAM role assumed by Vouch needs `eks:DescribeCluster` permission (at minimum) to run `aws eks update-kubeconfig`.
- For Access Entry management, the administrator's IAM role needs `eks:CreateAccessEntry`, `eks:AssociateAccessPolicy`, and related permissions.

### Cannot see resources in a specific namespace

- Check the access scope of the associated access policy. If the policy is scoped to specific namespaces, you can only access resources in those namespaces.
- Verify with: `aws eks list-associated-access-policies --cluster-name YOUR_CLUSTER_NAME --principal-arn YOUR_ROLE_ARN`.

### kubectl works but Helm does not

- Helm may require additional permissions beyond what `view` or `edit` policies provide (e.g., creating `ServiceAccount`, `Role`, or `RoleBinding` resources). Consider using `AmazonEKSAdminPolicy` or a custom RBAC role that grants the necessary permissions.



---

# Access GitHub Repos without Personal Access Tokens

Source: https://vouch.sh/docs/github/


GitHub personal access tokens are long-lived, broadly scoped, and stored in plaintext in shell configs and CI environments. Deploy keys are limited to a single repository per key and require manual management on every machine. A single leaked PAT can expose every private repo it has access to.

Vouch replaces both with 15-minute tokens issued through a [GitHub App](https://docs.github.com/en/apps) installed in your organization -- automatically scoped to the right repositories and tied to a hardware-verified identity. After running `vouch login`, you can clone, pull, and push to private repositories without managing any GitHub tokens yourself.

## How it works

When you perform a Git operation against a GitHub repository, the Vouch credential helper intercepts the authentication request and obtains a short-lived GitHub access token on your behalf:

1. **Git requests credentials** -- Git calls the Vouch credential helper when it needs to authenticate to `github.com`.
2. **Vouch exchanges your session** -- The credential helper contacts the Vouch server and exchanges your active hardware-backed session for a GitHub installation access token.
3. **GitHub App issues a token** -- The Vouch server uses a GitHub App installed in your organization to generate a short-lived access token scoped to the repositories your organization has granted access to.
4. **Git authenticates** -- The token is returned to Git and used for the current operation.

Key characteristics:

- **Short-lived tokens** -- Access tokens are valid for **15 minutes** and are never written to disk.
- **Multiple GitHub organizations** -- If your Vouch server is connected to more than one GitHub organization, Vouch automatically selects the correct token based on the repository you are accessing.
- **No stored secrets** -- There are no personal access tokens, SSH keys, or deploy keys to rotate or revoke.

---

## Step 1 -- Install the Vouch GitHub App (admin)

An organization administrator must connect at least one GitHub organization to the Vouch server before any team member can use the integration.

1. Navigate to https://{{< instance-url >}}/github/connect and follow the prompts to install the GitHub App in your GitHub organization. You can choose to grant access to all repositories or select specific ones.

2. After installing the app, confirm the organization connection on the GitHub connect page. The server will verify it can issue tokens for the connected organization.

3. Optionally, adjust which repositories the GitHub App has access to at any time through your GitHub organization settings under **Settings > GitHub Apps > Vouch**.

---

## Step 2 -- Configure Git Credential Helper

Before configuring the credential helper, make sure you have:

- The **Vouch CLI** installed and enrolled (see [Getting Started](/docs/getting-started/))
- A **verified identity** linked to your Vouch account (via your organization's SSO provider)

Run the setup command to install the Vouch credential helper for GitHub:

```
vouch setup github
```

This prints the Git configuration that will be added. To apply it automatically:

```
vouch setup github --configure
```

The command adds the following to your `~/.gitconfig`:

```ini
[credential "https://github.com"]
    helper = vouch
```

This tells Git to use the Vouch credential helper whenever it needs credentials for `github.com` over HTTPS.

---

## Step 3 -- Authenticate

If you have not already logged in today, authenticate with your YubiKey:

```
vouch login
```

Your session lasts for 8 hours. All Git operations during that window use the session automatically.

---

## Step 4 -- Use Git normally

With the credential helper configured and an active session, Git commands work without any extra flags or tokens:

```bash
# Clone a private repository
git clone https://github.com/your-org/private-repo.git

# Pull latest changes
cd private-repo
git pull

# Push commits
git add .
git commit -m "Update feature"
git push
```

Vouch handles authentication transparently. You do not need to enter a username, password, or token.

---

## Troubleshooting

### Authentication failed

```
fatal: Authentication failed for 'https://github.com/org/repo.git'
```

- Verify you have an active Vouch session by running `vouch login`.
- Confirm the credential helper is configured: `git config --global credential.https://github.com.helper` should return `vouch`.
- Check that the Vouch agent is running: `vouch status`.

### Organization not connected

```
error: GitHub organization "org-name" is not connected to this Vouch server
```

Your organization administrator has not yet installed the Vouch GitHub App for this organization. Ask them to connect the organization at https://{{< instance-url >}}/github/connect.

### Requires membership

```
error: you are not a member of the GitHub organization "org-name"
```

The GitHub App is installed, but your GitHub account is not a member of the organization. Verify that your GitHub username is associated with the correct organization and that your Vouch identity is linked to the right email address.

### Repository not accessible

```
error: repository not accessible with current token scope
```

The Vouch GitHub App does not have access to the specific repository you are trying to reach. Ask your organization administrator to update the app's repository permissions in GitHub organization settings.

### Multiple GitHub accounts

If you have multiple GitHub accounts and the wrong one is being used:

1. Check which credential helpers are configured: `git config --global --get-all credential.https://github.com.helper`
2. Ensure Vouch is listed and no other helpers are overriding it.
3. If you use different GitHub accounts for different organizations, Vouch handles this automatically by issuing tokens scoped to the correct organization based on the repository URL.

### Wrong credential helper being used

If another credential helper (such as `osxkeychain` or `manager`) is taking priority over Vouch:

1. List all configured helpers:
   ```
   git config --show-origin --get-all credential.https://github.com.helper
   ```
2. Remove or reorder conflicting entries so that `vouch` appears first.
3. Re-run `vouch setup github --configure` to ensure the configuration is correct.



---

# Authenticate to Container Registries without Stored Passwords

Source: https://vouch.sh/docs/docker/


Container registry credentials are a frequent source of leaks. Docker stores them in plaintext in `~/.docker/config.json`, and ECR's `get-login-password` tokens require a cron job or wrapper script to refresh every 12 hours. If you've ever committed a `.docker/config.json` to a dotfiles repo, those credentials are permanently exposed.

Vouch's [credential helper](https://docs.docker.com/engine/reference/commandline/login/#credential-helpers) generates tokens on demand -- no stored passwords, no refresh scripts, and full auditability through [ECR authentication](https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry_auth.html) logs. After a single `vouch login`, you can pull and push container images to supported registries without running `docker login` or managing any secrets.

## How it works

When Docker needs to authenticate to a container registry, it calls the Vouch credential helper instead of looking up stored passwords:

1. **Docker requests credentials** -- The Docker daemon calls the `docker-credential-vouch` helper when it needs to authenticate to a configured registry.
2. **Vouch exchanges your session** -- The credential helper contacts the Vouch server and exchanges your active hardware-backed session for registry-specific credentials.
3. **Short-lived token issued** -- The Vouch server returns a temporary token appropriate for the target registry (an AWS STS token for ECR, or a GitHub token for GHCR).
4. **Docker authenticates** -- The token is passed back to Docker and used for the current pull or push operation.

Key characteristics:

- **Short-lived tokens** -- Credentials are generated on demand and expire quickly. They are never persisted to disk.
- **No `docker login` required** -- The credential helper handles authentication transparently.
- **Multiple registries** -- You can configure Vouch for multiple registries simultaneously.

---

## Supported Registries

| Registry | Domain Pattern | Token Type |
|---|---|---|
| **AWS ECR** | `<account-id>.dkr.ecr.<region>.amazonaws.com` | AWS STS temporary credentials |
| **GitHub Container Registry** | `ghcr.io` | GitHub installation access token |

---

## Prerequisites

Before configuring the Docker integration, make sure you have:

- The **Vouch CLI** installed and enrolled (see [Getting Started](/docs/getting-started/))
- **Docker** installed and running
- For **ECR**: Your organization administrator has configured AWS IAM to trust the Vouch OIDC provider (see [AWS Integration](/docs/aws/))
- For **GHCR**: Your organization administrator has connected a GitHub organization to the Vouch server (see [GitHub Integration](/docs/github/))

---

## Step 1 -- Configure Docker Credential Helper

Run the setup command to install the Vouch Docker credential helper:

```
vouch setup docker
```

This prints the Docker configuration that will be added. To apply it automatically for a specific registry:

```bash
# Configure for GitHub Container Registry
vouch setup docker --configure ghcr.io

# Configure for AWS ECR
vouch setup docker --configure 123456789012.dkr.ecr.us-east-1.amazonaws.com
```

The command updates your `~/.docker/config.json` to register the Vouch credential helper for the specified registry:

```json
{
  "credHelpers": {
    "ghcr.io": "vouch",
    "123456789012.dkr.ecr.us-east-1.amazonaws.com": "vouch"
  }
}
```

You can configure multiple registries by running the command once for each registry domain.

---

## Step 2 -- Authenticate

If you have not already logged in today, authenticate with your YubiKey:

```
vouch login
```

Your session lasts for 8 hours. All Docker operations during that window use the session automatically.

---

## Step 3 -- Use Docker normally

With the credential helper configured and an active session, Docker commands work without any extra flags or manual login:

```bash
# Pull from GitHub Container Registry
docker pull ghcr.io/your-org/your-image:latest

# Pull from AWS ECR
docker pull 123456789012.dkr.ecr.us-east-1.amazonaws.com/your-repo:latest

# Push to GitHub Container Registry
docker push ghcr.io/your-org/your-image:v1.2.3

# Push to AWS ECR
docker push 123456789012.dkr.ecr.us-east-1.amazonaws.com/your-repo:v1.2.3
```

Vouch handles authentication transparently. You do not need to run `docker login` or `aws ecr get-login-password`.

---

## Registry-Specific Setup

### AWS ECR

For ECR authentication, Vouch uses your AWS integration to obtain temporary STS credentials, which are then exchanged for an ECR authorization token.

**IAM Policy** -- The IAM role assumed by Vouch must include ECR permissions. At minimum, the role needs:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "ecr:GetAuthorizationToken",
        "ecr:BatchGetImage",
        "ecr:GetDownloadUrlForLayer",
        "ecr:BatchCheckLayerAvailability"
      ],
      "Resource": "*"
    }
  ]
}
```

For push access, add these additional actions:

```json
{
  "Effect": "Allow",
  "Action": [
    "ecr:PutImage",
    "ecr:InitiateLayerUpload",
    "ecr:UploadLayerPart",
    "ecr:CompleteLayerUpload"
  ],
  "Resource": "arn:aws:ecr:us-east-1:123456789012:repository/*"
}
```

See the [AWS Integration](/docs/aws/) guide for full IAM configuration details.

### GitHub Container Registry (GHCR)

For GHCR authentication, Vouch uses the same GitHub App integration used for Git access. The token issued is scoped to the packages your organization has granted access to.

**Token scope** -- The GitHub App must have the `packages:read` permission (and `packages:write` if you need push access). Your organization administrator can configure this when installing the Vouch GitHub App.

See the [GitHub Integration](/docs/github/) guide for GitHub App setup details.

---

## Troubleshooting

### docker-credential-vouch not found

```
error getting credentials - err: exec: "docker-credential-vouch": executable file not found in $PATH
```

The `docker-credential-vouch` binary is not in your `PATH`. This binary is included with the Vouch CLI installation. Verify:

1. The Vouch CLI is installed: `vouch --version`
2. The credential helper binary exists: `which docker-credential-vouch`
3. If the binary is missing, reinstall the Vouch CLI or ensure the installation directory is in your `PATH`.

### Authentication failed

```
Error response from daemon: Head "https://ghcr.io/v2/...": denied
```

- Verify you have an active Vouch session: `vouch login`
- Check that the credential helper is configured for the registry: inspect `~/.docker/config.json` and confirm the registry appears in `credHelpers`.
- Ensure the Vouch agent is running: `vouch status`

### AWS not configured

```
error: AWS integration is not configured for this Vouch server
```

Your organization administrator has not set up the AWS OIDC provider. Ask them to complete the [AWS Integration](/docs/aws/) setup before using ECR through Vouch.

### Unsupported registry

```
error: registry "registry.example.com" is not supported by Vouch
```

Vouch currently supports AWS ECR and GitHub Container Registry (ghcr.io). Other registries are not yet supported. Check the [supported registries](#supported-registries) table above.

### Credentials not being used

If Docker appears to ignore the Vouch credential helper and prompts for a username and password:

1. Check for conflicting `credsStore` settings in `~/.docker/config.json`. A top-level `credsStore` may override individual `credHelpers` entries.
2. Remove or rename any conflicting credential store:
   ```json
   {
     "credsStore": "",
     "credHelpers": {
       "ghcr.io": "vouch"
     }
   }
   ```
3. Ensure there are no cached credentials for the registry. Run `docker logout <registry>` to clear any stored credentials, then retry.

---

## Helm & Compatible Tools

### Helm

Helm 3.8+ supports OCI registries for chart storage. Because Helm reads the Docker credential store, charts hosted in ECR or GHCR authenticate through Vouch automatically:

```bash
# Push a chart to ECR
helm push my-chart-0.1.0.tgz oci://123456789012.dkr.ecr.us-east-1.amazonaws.com/charts

# Pull a chart from ECR
helm pull oci://123456789012.dkr.ecr.us-east-1.amazonaws.com/charts/my-chart --version 0.1.0

# Install directly from OCI
helm install my-release oci://123456789012.dkr.ecr.us-east-1.amazonaws.com/charts/my-chart
```

### Other compatible tools

Any tool that reads `~/.docker/config.json` credHelpers will use Vouch automatically:

- **crane** -- Image manipulation without a Docker daemon
- **skopeo** -- Copy images between registries
- **Podman** -- Daemonless container engine
- **buildah** -- OCI image builder
- **ORAS** -- OCI artifacts (Wasm modules, ML models, signatures)



---

# Authenticate to AWS CodeArtifact without Stored Tokens

Source: https://vouch.sh/docs/codeartifact/


Every package manager has its own credential mechanism -- pip uses `~/.pip/pip.conf` or `PIP_INDEX_URL`, npm uses `.npmrc`, Cargo uses `~/.cargo/credentials.toml`, and Maven uses `settings.xml`. Each requires a different token format and rotation process. Keeping them all current across a growing team is a constant chore.

With [AWS CodeArtifact](https://docs.aws.amazon.com/codeartifact/latest/ug/welcome.html), you can unify these behind IAM, and with Vouch, the IAM credentials are hardware-backed and automatic. After a single `vouch login`, package managers like Cargo, pip, and npm can pull and publish packages from your AWS CodeArtifact repositories without manual token management.

## How it works

1. **Package manager requests a token** -- When a package manager needs to authenticate to an AWS CodeArtifact repository, the Vouch credential helper intercepts the request.
2. **OIDC to STS** -- Vouch exchanges your active hardware-backed session for temporary AWS STS credentials via `AssumeRoleWithWebIdentity`.
3. **STS to AWS CodeArtifact** -- Vouch calls `codeartifact:GetAuthorizationToken` with the STS credentials to obtain an AWS CodeArtifact authorization token.
4. **Package manager authenticates** -- The token is returned to the package manager and used for the current operation. Tokens are short-lived and never written to disk.

---

## Prerequisites

Before configuring the AWS CodeArtifact integration, make sure you have:

- The **Vouch CLI** installed and enrolled (see [Getting Started](/docs/getting-started/))
- The **[AWS integration](/docs/aws/)** configured (OIDC provider and IAM role)
- An **AWS CodeArtifact domain and repository** in your AWS account
- The IAM role must have `codeartifact:GetAuthorizationToken` and `sts:GetServiceBearerToken` permissions

---

## Step 1 -- Configure the Vouch CLI

Run the setup command to configure Vouch for your AWS CodeArtifact repository:

```bash
vouch setup codeartifact --tool cargo --repository my-repo [--domain my-domain] [--domain-owner 123456789012] [--region us-east-1] [--profile my-profile]
```

| Flag | Description |
|---|---|
| `--tool` | Package manager to configure: `cargo`, `pip`, or `npm` (required) |
| `--repository` | The AWS CodeArtifact repository name (required) |
| `--domain` | The AWS CodeArtifact domain name (optional if a profile is configured) |
| `--domain-owner` | AWS account ID that owns the domain (optional if a profile is configured) |
| `--region` | AWS region (default: `us-east-1`; optional if a profile is configured) |
| `--profile` | Named profile to use or create (see [Profiles](#profiles) below) |

This configures the appropriate credential helper for your package manager and writes the necessary configuration files.

---

## Profiles

Vouch supports named profiles for AWS CodeArtifact, allowing you to store domain, domain owner, and region settings and reuse them across commands. Profiles are stored in `~/.vouch/config.json`.

### Default profile

When you run `vouch setup codeartifact` with `--domain`, `--domain-owner`, and `--region`, these values are saved to the default profile. Subsequent commands can omit these flags:

```bash
# First time: specify all values (saved to default profile)
vouch setup codeartifact --tool cargo --domain my-domain --domain-owner 123456789012 --repository my-repo --region us-east-1

# Later: only --tool and --repository are needed
vouch setup codeartifact --tool pip --repository my-pypi-repo
```

### Named profiles

Use `--profile` to create and manage separate configurations for different AWS CodeArtifact domains or accounts:

```bash
# Create a profile for the shared artifacts account
vouch setup codeartifact --tool cargo --domain shared-packages --domain-owner 111111111111 --repository cargo-store --profile shared

# Create a profile for the team account
vouch setup codeartifact --tool cargo --domain team-packages --domain-owner 222222222222 --repository team-cargo --profile team
```

Named profiles are referenced by other commands using the `--profile` flag.

---

## Supported package managers

| Package Manager | Protocol | Authentication Method | Token Model |
|---|---|---|---|
| **Cargo** | `sparse+https` | Bearer token via credential provider | Dynamic (fetched on demand) |
| **pip** | HTTPS | Token embedded in index URL | Dynamic (fetched on demand) |
| **npm** | HTTPS | Bearer token via `.npmrc` | Static (embedded in `.npmrc`, ~12h expiry) |

**Dynamic tokens** (Cargo, pip) are fetched transparently on each operation and do not expire during normal use. **Static tokens** (npm) are written to `.npmrc` during setup and expire after approximately 12 hours. When an npm token expires, re-run `vouch setup codeartifact --tool npm --repository <REPO>` to refresh it.

---

## Step 2 -- Authenticate

If you have not already logged in today, authenticate with your YubiKey:

```
vouch login
```

Your session lasts for 8 hours. All AWS CodeArtifact operations during that window use the session automatically.

---

## Step 3 -- Use your package manager normally

### Cargo

```bash
# Build a project that depends on private crates
cargo build

# Publish a crate to your AWS CodeArtifact registry
cargo publish --registry my-codeartifact-registry
```

Cargo tokens are fetched dynamically on each operation via the credential provider. No token refresh is needed.

### pip

```bash
# Install a package from your AWS CodeArtifact repository
pip install my-package --index-url https://my-domain-123456789012.d.codeartifact.us-east-1.amazonaws.com/pypi/my-repo/simple/

# Install from requirements.txt
pip install -r requirements.txt
```

pip tokens are fetched dynamically by embedding the credential helper in the index URL. No token refresh is needed.

### npm

```bash
# Install packages
npm install

# Publish a package
npm publish
```

npm uses a static token written to `.npmrc`. If you see authentication errors after ~12 hours, re-run `vouch setup codeartifact --tool npm --repository <REPO>` to refresh the token.

---

## Environment variables

You can inject a `CODEARTIFACT_AUTH_TOKEN` environment variable into your shell or a subprocess using `vouch env` or `vouch exec`. This is useful for tools that read the token from the environment (such as Maven or custom scripts).

### `vouch env`

Output the token as a shell export statement:

```bash
eval "$(vouch env --type codeartifact [--ca-domain <DOMAIN>] [--ca-domain-owner <ACCOUNT_ID>] [--ca-region <REGION>] [--ca-profile <PROFILE>] [--shell <SHELL>])"
```

This sets `CODEARTIFACT_AUTH_TOKEN` in your current shell.

### `vouch exec`

Run a command with the token injected:

```bash
vouch exec --type codeartifact [--ca-domain <DOMAIN>] [--ca-domain-owner <ACCOUNT_ID>] [--ca-region <REGION>] [--ca-profile <PROFILE>] -- mvn deploy
```

| Flag | Description |
|---|---|
| `--ca-domain` | AWS CodeArtifact domain name (optional if a profile is configured) |
| `--ca-domain-owner` | AWS account ID that owns the domain (optional if a profile is configured) |
| `--ca-region` | AWS region (optional if a profile is configured) |
| `--ca-profile` | Named AWS CodeArtifact profile to use |

---

## Cross-partition support

Vouch supports AWS CodeArtifact across all AWS partitions:

| Partition | Region Examples |
|---|---|
| **Standard** (`aws`) | `us-east-1`, `eu-west-1`, `ap-southeast-1` |
| **China** (`aws-cn`) | `cn-north-1`, `cn-northwest-1` |
| **GovCloud** (`aws-us-gov`) | `us-gov-west-1`, `us-gov-east-1` |

Use the `--region` flag during setup to configure the appropriate partition.

---

## Troubleshooting

### "Access denied" when fetching packages

- Verify your IAM role has the following permissions:
  - `codeartifact:GetAuthorizationToken`
  - `codeartifact:GetRepositoryEndpoint`
  - `codeartifact:ReadFromRepository`
  - `sts:GetServiceBearerToken`
- Confirm the AWS CodeArtifact domain and repository names are correct.
- Check that you have an active Vouch session: `vouch login`.

### "Token is expired"

- For **npm**: Re-run `vouch setup codeartifact --tool npm --repository <REPO>` to refresh the static token in `.npmrc`.
- For **Cargo/pip**: Run `vouch login` to refresh your session. Dynamic tokens are fetched on demand, so expiry usually indicates the Vouch session itself has ended.

### Wrong domain or repository

- Run `vouch setup codeartifact` again with the correct `--tool` and `--repository` flags.
- If using profiles, check `~/.vouch/config.json` for the stored domain and region values.
- Check your package manager's configuration files for conflicting settings.

### Package manager not using Vouch

- Ensure no environment variables (e.g., `CODEARTIFACT_AUTH_TOKEN`) are overriding the credential helper.
- Verify the package manager configuration points to the correct AWS CodeArtifact endpoint.

---

## Maven

For Maven projects, use `vouch credential codeartifact` or `vouch exec` to obtain a token:

```bash
# Option 1: Set the token in your shell
export CODEARTIFACT_AUTH_TOKEN=$(vouch credential codeartifact)

# Option 2: Use vouch exec to inject the token into Maven
vouch exec --type codeartifact -- mvn deploy -s settings.xml
```

If you need to specify the domain explicitly:

```bash
export CODEARTIFACT_AUTH_TOKEN=$(vouch credential codeartifact --domain my-domain --domain-owner 123456789012)
```

In your `settings.xml`, reference the environment variable as the password:

```xml
<server>
  <id>codeartifact</id>
  <username>aws</username>
  <password>${env.CODEARTIFACT_AUTH_TOKEN}</password>
</server>
```

---

## Cross-Account Access

If your AWS CodeArtifact domain is in a different AWS account, use named profiles to manage access:

```bash
# Set up a Vouch AWS profile for the artifacts account
vouch setup aws \
  --role arn:aws:iam::ARTIFACTS_ACCOUNT:role/CodeArtifactReader \
  --profile vouch-artifacts

# Create an AWS CodeArtifact profile that uses the artifacts account
vouch setup codeartifact \
  --tool npm \
  --domain shared-packages \
  --domain-owner ARTIFACTS_ACCOUNT \
  --repository npm-store \
  --profile artifacts

# Use the profile when fetching credentials
vouch credential codeartifact --profile artifacts
```

---

## Token Lifetime

AWS CodeArtifact authorization tokens are valid for up to **12 hours** by default. For Cargo and pip, Vouch fetches tokens dynamically on each operation, so expiry is transparent. For npm, the token is embedded in `.npmrc` and must be refreshed by re-running `vouch setup codeartifact --tool npm` when it expires. If your Vouch session (8 hours) has expired, run `vouch login` first.



---

# Access AWS CodeCommit without Git Credentials

Source: https://vouch.sh/docs/codecommit/


AWS offers three ways to authenticate to [AWS CodeCommit](https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html): SSH keys, HTTPS Git credentials (static username/password from IAM), and IAM access keys with a credential helper. All three involve long-lived secrets that need to be distributed and rotated.

Vouch provides a fourth option: short-lived STS credentials that require no static secrets at all. After a single `vouch login`, you can clone, pull, and push to AWS CodeCommit repositories without managing Git credentials or IAM access keys. Vouch supports both HTTPS credential helper and native `codecommit://` remote helper authentication.

## How it works

1. **Git requests credentials** -- Git calls the Vouch credential helper when it needs to authenticate to an AWS CodeCommit repository.
2. **OIDC to STS** -- Vouch exchanges your active hardware-backed session for temporary AWS STS credentials via `AssumeRoleWithWebIdentity`.
3. **SigV4 signing** -- Vouch uses the STS credentials to sign the Git HTTP request with AWS Signature Version 4, authenticating directly to AWS CodeCommit without generating intermediate HTTPS Git credentials.
4. **Git authenticates** -- The signed credentials are returned to Git and used for the current operation.

Key characteristics:

- **Short-lived credentials** -- Git credentials are derived from your Vouch session and expire when the session ends.
- **No stored secrets** -- There are no IAM access keys, HTTPS Git credentials, or SSH keys to manage.
- **Native SigV4** -- Vouch signs requests directly using the AWS SigV4 protocol, bypassing the legacy HTTPS Git credential system.
- **Two authentication methods** -- Use HTTPS URLs with the credential helper, or `codecommit://` URLs with the native remote helper.

---

## Prerequisites

Before configuring the AWS CodeCommit integration, make sure you have:

- The **Vouch CLI** installed and enrolled (see [Getting Started](/docs/getting-started/))
- The **[AWS integration](/docs/aws/)** configured (OIDC provider and IAM role)
- The IAM role must have `codecommit:GitPull` and `codecommit:GitPush` permissions on the target repositories

---

## Step 1 -- Configure the Git credential helper

Run the setup command to install the Vouch credential helper for AWS CodeCommit:

```
vouch setup codecommit [--region <REGION>] [--profile <PROFILE>] [--configure]
```

| Flag | Description |
|---|---|
| `--region` | AWS region (default: wildcard matching all regions) |
| `--profile` | AWS profile to use (defaults to auto-detected vouch profile) |
| `--configure` | Apply the configuration automatically (without this flag, the command only prints the configuration) |

This configures Git to use Vouch as the credential helper for AWS CodeCommit HTTPS URLs across all supported AWS partitions. It adds the following to your `~/.gitconfig`:

```ini
[credential "https://git-codecommit.*.amazonaws.com"]
    helper = vouch
    useHttpPath = true

[credential "https://git-codecommit.*.amazonaws.com.cn"]
    helper = vouch
    useHttpPath = true

[credential "https://git-codecommit.*.amazonaws.eu"]
    helper = vouch
    useHttpPath = true
```

The setup also installs the native `git-remote-codecommit` helper as a symlink at `~/.local/bin/git-remote-codecommit`, enabling `codecommit://` URL support (see below).

---

## Step 2 -- Authenticate

If you have not already logged in today, authenticate with your YubiKey:

```
vouch login
```

Your session lasts for 8 hours. All Git operations during that window use the session automatically.

---

## Step 3 -- Use Git normally

With the credential helper configured and an active session, Git commands work without any extra flags or tokens:

```bash
# Clone an AWS CodeCommit repository
git clone https://git-codecommit.us-east-1.amazonaws.com/v1/repos/my-repo

# Pull latest changes
cd my-repo
git pull

# Push commits
git add .
git commit -m "Update feature"
git push
```

Vouch handles authentication transparently. You do not need to enter a username, password, or configure IAM HTTPS Git credentials.

---

## Native `codecommit://` remote helper

Vouch ships its own native `git-remote-codecommit` remote helper, which is installed automatically by `vouch setup codecommit`. This provides `codecommit://` URL support without requiring any external dependencies -- no Python or `pip install` needed.

The remote helper reads credentials directly from the AWS credential chain, bypassing Git's credential helper system entirely. This avoids known conflicts with macOS Keychain and Git Credential Manager.

### URL formats

| Format | Description |
|---|---|
| `codecommit://my-repo` | Uses the default AWS profile and region |
| `codecommit://vouch@my-repo` | Uses the `vouch` AWS profile |
| `codecommit::us-west-2://my-repo` | Uses a specific region |
| `codecommit::us-west-2://vouch@my-repo` | Uses a specific region and profile |

### Usage

```bash
# Clone using the default profile
git clone codecommit://my-repo

# Clone using a specific AWS profile
git clone codecommit://vouch@my-repo

# Clone from a specific region
git clone codecommit::us-west-2://vouch@my-repo
```

The profile name before `@` must match your AWS profile (typically `vouch`). All subsequent Git operations (`push`, `pull`, `fetch`) work normally.

### When to use `codecommit://` URLs

Use `codecommit://` URLs when:

- You have multiple credential helpers installed and experience conflicts (macOS Keychain, Git Credential Manager)
- You want to avoid HTTPS URL region-specific hostnames
- You need to work with multiple AWS profiles or regions across repositories

---

## Cross-partition support

Vouch supports AWS CodeCommit across all AWS partitions:

| Partition | URL Suffix | Region Examples |
|---|---|---|
| **Standard** (`aws`) | `.amazonaws.com` | `us-east-1`, `eu-west-1`, `ap-southeast-1` |
| **China** (`aws-cn`) | `.amazonaws.com.cn` | `cn-north-1`, `cn-northwest-1` |
| **EU Sovereign Cloud** | `.amazonaws.eu` | EU sovereign regions |

The credential helper is configured for all three partitions automatically during setup.

---

## Troubleshooting

### Authentication failed

```
fatal: Authentication failed for 'https://git-codecommit.us-east-1.amazonaws.com/v1/repos/my-repo'
```

- Verify you have an active Vouch session: `vouch login`.
- Confirm the credential helper is configured: `git config --global credential.https://git-codecommit.*.amazonaws.com.helper` should return `vouch`.
- Check that the Vouch agent is running: `vouch status`.

### "Not authorized to perform codecommit:GitPull"

- Verify the IAM role you are assuming has the correct AWS CodeCommit permissions.
- Check that the IAM trust policy allows `AssumeRoleWithWebIdentity` from the Vouch OIDC provider.

### Wrong region

- AWS CodeCommit repository URLs include the region (e.g., `git-codecommit.us-east-1.amazonaws.com`). Make sure you are using the correct region for your repository.
- Alternatively, use `codecommit://` URLs with an explicit region: `codecommit::us-east-1://vouch@my-repo`.

### Another credential helper is interfering

1. List all configured credential helpers:
   ```
   git config --show-origin --get-all credential.https://git-codecommit.*.amazonaws.com.helper
   ```
2. Remove or reorder conflicting entries so that `vouch` appears first.
3. Re-run `vouch setup codecommit` to ensure the configuration is correct.
4. Alternatively, switch to `codecommit://` URLs which bypass Git's credential helper system entirely.

---

## Authentication method comparison

| Method | Credential Type | Conflicts | Works with Vouch |
|---|---|---|---|
| SSH keys | Static key pair | No | Not through Vouch |
| HTTPS Git credentials | Static username/password | macOS Keychain, GCM | Not through Vouch |
| HTTPS credential helper (Vouch) | SigV4-signed (from STS) | macOS Keychain, GCM | Yes |
| `codecommit://` remote helper (Vouch) | SigV4-signed (from STS) | None | Yes (recommended) |



---

# Authenticate to Private Cargo Registries

Source: https://vouch.sh/docs/cargo/


Cargo's default credential mechanism stores a plaintext token in `~/.cargo/credentials.toml` with no expiration. If that file is committed to a dotfiles repo, included in a backup, or read by malware, the token works forever.

Vouch's credential provider replaces this with tokens derived from your hardware-backed session -- short-lived, never written to disk, and revoked the moment your session ends. After a single `vouch login`, commands like `cargo build`, `cargo publish`, and `cargo add` work seamlessly against private registries.

## How it works

Vouch implements the [Cargo credential provider protocol](https://doc.rust-lang.org/cargo/reference/credential-provider-protocol.html) (RFC 2730 / RFC 3139). When Cargo needs to authenticate to a private registry, it delegates to the Vouch credential provider:

1. **Cargo requests a token** -- Cargo calls the Vouch credential provider binary when it needs to authenticate to a configured private registry.
2. **Vouch exchanges your session** -- The credential provider contacts the Vouch server and exchanges your active hardware-backed session for a registry-scoped Bearer token.
3. **Token derived from your session** -- The token is derived from your Vouch session and is scoped to the specific registry. It is short-lived and never written to disk.
4. **Cargo authenticates** -- The Bearer token is sent to the registry as part of the HTTP request, and the operation proceeds.

Key characteristics:

- **Short-lived tokens** -- Tokens are derived from your Vouch session and expire when the session ends.
- **No stored secrets** -- There are no tokens in `~/.cargo/credentials.toml` or environment variables to manage.
- **Standard protocol** -- Vouch uses Cargo's official credential provider protocol, so it works with any registry that supports Bearer token authentication.

---

## Prerequisites

Before configuring the Cargo integration, make sure you have:

- The **Vouch CLI** installed and enrolled (see [Getting Started](/docs/getting-started/))
- **Cargo** installed via [rustup](https://rustup.rs/) (version **1.74** or later, which includes credential provider protocol support)
- A **private Cargo registry** that supports Bearer token authentication

---

## Step 1 -- Configure Cargo Credential Provider

Run the setup command to install the Vouch credential provider for Cargo:

```
vouch setup cargo
```

This prints the Cargo configuration that will be added. To apply it automatically:

```
vouch setup cargo --configure
```

To configure a specific named registry:

```
vouch setup cargo --registry my-private-registry --configure
```

The command adds the following to your `~/.cargo/config.toml`:

```toml
[registry]
global-credential-providers = ["vouch"]

[registries.my-private-registry]
index = "sparse+https://cargo.example.com/index/"
credential-provider = ["vouch"]
```

The `global-credential-providers` setting registers Vouch as the default credential provider for all registries. You can also configure it per-registry using the `credential-provider` key under a specific `[registries.*]` section.

---

## Step 2 -- Authenticate

If you have not already logged in today, authenticate with your YubiKey:

```
vouch login
```

Your session lasts for 8 hours. All Cargo operations during that window use the session automatically.

---

## Step 3 -- Use Cargo normally

With the credential provider configured and an active session, Cargo commands work without any extra flags or manual token management:

```bash
# Build a project that depends on private crates
cargo build

# Publish a crate to your private registry
cargo publish --registry my-private-registry

# Add a dependency from a private registry
cargo add my-crate --registry my-private-registry

# Update dependencies including private ones
cargo update
```

Vouch handles authentication transparently. You do not need to run `cargo login` or set any environment variables.

---

## Private Registry Configuration

To use a private Cargo registry with Vouch, you need to define the registry in your Cargo configuration. Add the following to your project's `.cargo/config.toml` or your global `~/.cargo/config.toml`:

```toml
[registries.my-private-registry]
index = "sparse+https://cargo.example.com/index/"
credential-provider = ["vouch"]
```

If your `Cargo.toml` references dependencies from the private registry:

```toml
[dependencies]
my-crate = { version = "1.0", registry = "my-private-registry" }
```

Cargo will automatically call the Vouch credential provider when it needs to fetch or publish crates from this registry.

### Registry server requirements

The private registry must support:

- **Sparse index protocol** (recommended) or Git index protocol
- **Bearer token authentication** via the `Authorization` HTTP header
- The token format issued by Vouch (a signed JWT)

Consult your registry server's documentation to confirm Bearer token support.

---

## Troubleshooting

### Not authenticated

```
error: failed to get token for registry `my-private-registry`
caused by: not logged in to registry `my-private-registry`
```

- Verify you have an active Vouch session: `vouch login`
- Check that the Vouch agent is running: `vouch status`
- Confirm the credential provider is configured for the registry: inspect `~/.cargo/config.toml` and verify the `credential-provider` key is set to `["vouch"]`.

### Cargo not using Vouch

If Cargo prompts you for a token or uses a different credential provider:

1. Check your Cargo configuration for conflicting credential provider settings:
   ```
   cargo config get registry.global-credential-providers
   ```
2. Ensure no `CARGO_REGISTRY_TOKEN` or `CARGO_REGISTRIES_*_TOKEN` environment variables are set, as these override credential providers:
   ```bash
   env | grep CARGO_REGISTR
   ```
3. Re-run `vouch setup cargo --configure` to ensure the configuration is correct.

### Unsupported protocol version

```
error: credential provider `vouch` failed: unsupported credential provider protocol version
```

The Cargo credential provider protocol requires **Cargo 1.74 or later**. Check your Cargo version:

```
cargo --version
```

If your version is older than 1.74, update via rustup:

```
rustup update stable
```

### Token not cached

If Vouch appears to request a new token for every Cargo operation (causing delays):

- This is expected behavior. Vouch derives tokens from your active session on each request rather than caching them to disk. The overhead is minimal (typically under 100ms).
- If latency is a concern, ensure the Vouch agent is running (`vouch status`), as it keeps your session in memory for fast token derivation.

### Multiple credential providers

If you have multiple credential providers configured and they conflict:

1. Check the provider order in `~/.cargo/config.toml`:
   ```toml
   [registry]
   global-credential-providers = ["vouch", "cargo:token"]
   ```
   Cargo tries providers in order. Place `vouch` first to ensure it is used before any fallback providers.

2. To use Vouch for only specific registries, remove it from `global-credential-providers` and set it per-registry instead:
   ```toml
   [registries.my-private-registry]
   credential-provider = ["vouch"]
   ```



---

# Add Hardware-Backed Sign-In to Your Application

Source: https://vouch.sh/docs/applications/


Building phishing-resistant authentication from scratch means implementing WebAuthn flows, managing attestation, and handling device lifecycle -- a significant engineering investment for a startup. If you already have an OIDC-compatible application, you can get hardware-backed sign-in without any of that.

Vouch is a fully compliant [OpenID Connect](https://openid.net/connect/) (OIDC) provider. You add "Sign in with Vouch" to any web application, single-page app, or native CLI tool using standard OIDC libraries. Every login is backed by a hardware security key, giving your application phishing-resistant authentication without building it yourself.

## What you'll build

By following this guide, you will integrate Vouch as an OIDC identity provider into your application. Users will authenticate with their YubiKey through Vouch, and your application will receive verified identity information including:

- A unique, stable user identifier (`sub` claim)
- The user's email address
- Hardware attestation claims proving the authentication was performed with a verified security key
- Organization membership information

This works with any framework or library that supports OpenID Connect or OAuth 2.0 authorization code flow.

---

## Prerequisites

Before integrating Vouch into your application, you need:

- A **registered OAuth application** at https://{{< instance-url >}}/applications
- Your application's **client ID** (`client_id`)
- Your application's **client secret** (`client_secret`)
- A configured **redirect URI** (e.g., `https://your-app.example.com/auth/callback`)

To register an application, ask your Vouch organization administrator to create one at https://{{< instance-url >}}/applications, or use the API if you have admin access.

---

## Access Scopes

Vouch supports two access scopes that control what identity information is included in tokens:

| Scope | Description | Claims Included |
|---|---|---|
| `openid` | **Required.** Identifies this as an OIDC authentication request. | `sub`, `iss`, `aud`, `exp`, `iat` |
| `email` | User email address. | `email`, `email_verified` |

Request scopes in the authorization request by including them in the `scope` parameter, space-separated:

```
scope=openid email
```

---

## Configuration Reference

Use the following endpoints and values to configure your OIDC client library. All URLs are relative to your Vouch server instance.

| Parameter | Value |
|---|---|
| **Discovery URL** | `https://{{< instance-url >}}/.well-known/openid-configuration` |
| **Issuer** | `https://{{< instance-url >}}` |
| **Authorization Endpoint** | `https://{{< instance-url >}}/oauth/authorize` |
| **Token Endpoint** | `https://{{< instance-url >}}/oauth/token` |
| **UserInfo Endpoint** | `https://{{< instance-url >}}/oauth/userinfo` |
| **JWKS URI** | `https://{{< instance-url >}}/.well-known/jwks.json` |
| **Signing Algorithm** | `ES256` |
| **Supported Scopes** | `openid`, `email` |
| **Device Authorization Endpoint** | `https://{{< instance-url >}}/oauth/device/code` |
| **Device Verification URL** | `https://{{< instance-url >}}/oauth/device` |
| **PAR Endpoint** | `https://{{< instance-url >}}/oauth/par` |
| **Token Revocation Endpoint** | `https://{{< instance-url >}}/oauth/revoke` |
| **Token Introspection Endpoint** | `https://{{< instance-url >}}/oauth/introspect` |

Most OIDC libraries can auto-configure themselves from the Discovery URL alone.

---

## Vouch-Specific Claims

Vouch ID tokens include additional claims beyond the standard OIDC claims. These provide hardware attestation information that your application can use to enforce security policies.

| Claim | Type | Description |
|---|---|---|
| `hardware_verified` | boolean | `true` if the authentication was performed using a verified hardware security key. Always `true` for Vouch-issued tokens. |
| `hardware_aaguid` | string | The AAGUID (Authenticator Attestation GUID) of the hardware key used for authentication. This identifies the make and model of the security key (e.g., YubiKey 5 series). |
| `cnf` | object | Confirmation claim containing key binding information per RFC 7800. Includes a `kid` field referencing the specific credential used. |
| `amr` | array | Authentication methods used (e.g., `["hwk", "pin"]`). |
| `acr` | string | Authentication context class (e.g., NIST AAL3 for hardware MFA). |

Example ID token payload with Vouch-specific claims:

```json
{
  "iss": "https://{{< instance-url >}}",
  "sub": "user_abc123",
  "aud": "your-client-id",
  "exp": 1700000000,
  "iat": 1699996400,
  "email": "alice@example.com",
  "email_verified": true,
  "hardware_verified": true,
  "hardware_aaguid": "2fc0579f-8113-47ea-b116-bb5a8db9202a",
  "amr": ["hwk", "pin"],
  "acr": "urn:nist:authentication:assurance-level:aal3",
  "cnf": {
    "kid": "credential_xyz789"
  }
}
```

Your application can use the `hardware_verified` claim to enforce that only hardware-backed authentications are accepted, and the `hardware_aaguid` claim to restrict access to specific security key models.

### Accessing Vouch claims in your application

Regardless of your framework, the Vouch-specific claims are available in the ID token's payload after standard OIDC verification. Here is a generic example:

```javascript
// After verifying the ID token through your OIDC library:
const hardwareVerified = idToken.hardware_verified; // boolean
const keyModel = idToken.hardware_aaguid;           // string (AAGUID)
const keyBinding = idToken.cnf?.kid;                // string (credential ID)

// Enforce hardware-only authentication
if (!hardwareVerified) {
  throw new Error("Hardware key verification required");
}
```

---

## Token Lifetime and Refresh

Vouch access tokens are short-lived. Your application should handle token expiry gracefully:

- **Server-side applications** -- Check token expiry before using it. If expired, redirect the user through the authorization flow again. Vouch does not issue refresh tokens.
- **Single-page applications** -- Use `automaticSilentRenew` (available in `oidc-client-ts`) to transparently renew tokens before they expire. See the [React]({{< ref "/docs/applications/react" >}}), [Vue]({{< ref "/docs/applications/vue" >}}), and [Vanilla JS]({{< ref "/docs/applications/vanilla-js" >}}) guides for configuration details.
- **Native CLI applications** -- Use the device authorization flow (RFC 8628) and prompt the user to re-authenticate when the token expires.

---

## Service-to-Service (M2M) Authentication

For server-to-server communication where no human user is involved, Vouch supports **Token Exchange** (RFC 8693). A service with a valid Vouch token can exchange it for a new token scoped to a different audience, enabling secure service-to-service calls.

### Token Exchange Flow

1. **Service A** authenticates a user through the standard OIDC flow and obtains an access token.
2. **Service A** calls **Service B** and needs to pass along the user's identity.
3. **Service A** exchanges its token for a new token with **Service B's** audience by calling the token endpoint.

### Token Exchange Request

```bash
curl -X POST https://{{< instance-url >}}/oauth/token \
  -d "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
  -d "subject_token=<access-token>" \
  -d "subject_token_type=urn:ietf:params:oauth:token-type:access_token" \
  -d "audience=service-b-client-id" \
  -d "client_id=service-a-client-id" \
  -d "client_secret=service-a-client-secret"
```

### Token Exchange Response

```json
{
  "access_token": "eyJhbGciOiJFUzI1NiIs...",
  "issued_token_type": "urn:ietf:params:oauth:token-type:access_token",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

The new token is scoped to Service B's audience and inherits the user's identity claims from the original token. Service B can validate this token by checking the `aud` claim and verifying the signature against the Vouch JWKS endpoint.

---

## Troubleshooting

### Discovery endpoint not reachable

```
Error: unable to fetch OpenID configuration from https://{{< instance-url >}}/.well-known/openid-configuration
```

- Verify the Vouch server URL is correct and accessible from your application server.
- Check that your application can reach the Vouch server (no firewall or network restrictions).
- Ensure the URL does not have a trailing slash.

### Invalid client_id or client_secret

```
error: invalid_client
```

- Verify the `client_id` and `client_secret` match what was registered on the Vouch [applications page](https://{{< instance-url >}}/applications).
- Check that the client credentials are not expired or revoked.
- Ensure the credentials are being sent correctly (as form parameters for the token endpoint, not as JSON).

### Redirect URI mismatch

```
error: redirect_uri_mismatch
```

The redirect URI in your authorization request does not match any URI registered for this client. Ensure:

- The redirect URI exactly matches what was registered (including protocol, host, port, and path).
- There are no trailing slashes or query parameters that differ.
- If using localhost for development, the port must match exactly.

### ID token validation fails

```
Error: ID token signature verification failed
```

- Ensure your library is configured to use the `ES256` signing algorithm. Vouch uses ECDSA with P-256, not RSA.
- Verify the JWKS endpoint is reachable: `https://{{< instance-url >}}/.well-known/jwks.json`
- Check that the `iss` claim matches your configured issuer URL exactly.
- Ensure your server's clock is synchronized (token validation is time-sensitive).

### CORS errors in browser applications

```
Access to fetch at 'https://{{< instance-url >}}/oauth/token' has been blocked by CORS policy
```

For single-page applications, ensure your application's origin is registered as an allowed origin on the Vouch [applications page](https://{{< instance-url >}}/applications). The Vouch server must include your origin in its CORS `Access-Control-Allow-Origin` response header.

### Device code expired

```
error: expired_token
```

The user did not complete authentication within the allowed time window. Request a new device code and display the new `user_code` to the user. The default expiration is 10 minutes.


---

## Rails (OmniAuth)

Source: https://vouch.sh/docs/applications/rails/


> See the [Applications overview]({{< ref "/docs/applications" >}}) for prerequisites, configuration endpoints, and available scopes.

[OmniAuth OpenID Connect](https://github.com/omniauth/omniauth_openid_connect) provides a standard OIDC strategy for Rails applications.

Add the `omniauth_openid_connect` gem to your `Gemfile`:

```ruby
gem 'omniauth_openid_connect'
```

Configure the provider in `config/initializers/omniauth.rb`:

```ruby
Rails.application.config.middleware.use OmniAuth::Builder do
  provider :openid_connect, {
    name: :vouch,
    scope: [:openid, :email],
    response_type: :code,
    issuer: "https://{{< instance-url >}}",
    discovery: true,
    client_options: {
      identifier: ENV["VOUCH_CLIENT_ID"],
      secret: ENV["VOUCH_CLIENT_SECRET"],
      redirect_uri: "https://your-app.example.com/auth/vouch/callback"
    }
  }
end
```

Add the callback route in `config/routes.rb`:

```ruby
get "/auth/vouch/callback", to: "sessions#create"
post "/auth/vouch/callback", to: "sessions#create"
```

Handle the callback in `app/controllers/sessions_controller.rb`:

```ruby
class SessionsController < ApplicationController
  def create
    auth = request.env["omniauth.auth"]
    user = User.find_or_create_by(vouch_id: auth.uid) do |u|
      u.email = auth.info.email
      u.name = auth.info.name
    end
    session[:user_id] = user.id
    redirect_to root_path, notice: "Signed in successfully."
  end
end
```


---

## Django (django-allauth)

Source: https://vouch.sh/docs/applications/django/


> See the [Applications overview]({{< ref "/docs/applications" >}}) for prerequisites, configuration endpoints, and available scopes.

Install [django-allauth](https://django-allauth.readthedocs.io/) with OpenID Connect support:

```bash
pip install django-allauth[openid_connect]
```

Add the provider to your `settings.py`:

```python
INSTALLED_APPS = [
    # ...
    "allauth",
    "allauth.account",
    "allauth.socialaccount",
    "allauth.socialaccount.providers.openid_connect",
]

SOCIALACCOUNT_PROVIDERS = {
    "openid_connect": {
        "APPS": [
            {
                "provider_id": "vouch",
                "name": "Vouch",
                "client_id": os.environ["VOUCH_CLIENT_ID"],
                "secret": os.environ["VOUCH_CLIENT_SECRET"],
                "settings": {
                    "server_url": "https://{{< instance-url >}}",
                },
            },
        ],
    },
}
```

Add the allauth URLs to your `urls.py`:

```python
from django.urls import path, include

urlpatterns = [
    # ...
    path("accounts/", include("allauth.urls")),
]
```


---

## Express.js (Passport)

Source: https://vouch.sh/docs/applications/express/


> See the [Applications overview]({{< ref "/docs/applications" >}}) for prerequisites, configuration endpoints, and available scopes.

Install the required packages:

```bash
npm install passport passport-openidconnect express-session
```

Configure [Passport](https://www.passportjs.org/) in your Express application:

```javascript
const express = require("express");
const session = require("express-session");
const passport = require("passport");
const OpenIDConnectStrategy = require("passport-openidconnect");

const app = express();

app.use(
  session({
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
  })
);

app.use(passport.initialize());
app.use(passport.session());

passport.use(
  "vouch",
  new OpenIDConnectStrategy(
    {
      issuer: "https://{{< instance-url >}}",
      authorizationURL: "https://{{< instance-url >}}/oauth/authorize",
      tokenURL: "https://{{< instance-url >}}/oauth/token",
      userInfoURL: "https://{{< instance-url >}}/oauth/userinfo",
      clientID: process.env.VOUCH_CLIENT_ID,
      clientSecret: process.env.VOUCH_CLIENT_SECRET,
      callbackURL: "https://your-app.example.com/auth/vouch/callback",
      scope: "openid email",
    },
    (issuer, profile, done) => {
      // Find or create user based on profile
      return done(null, profile);
    }
  )
);

passport.serializeUser((user, done) => done(null, user));
passport.deserializeUser((user, done) => done(null, user));

app.get("/auth/vouch", passport.authenticate("vouch"));

app.get(
  "/auth/vouch/callback",
  passport.authenticate("vouch", {
    successRedirect: "/",
    failureRedirect: "/login",
  })
);

app.listen(3000);
```


---

## Next.js (NextAuth.js)

Source: https://vouch.sh/docs/applications/nextjs/


> See the [Applications overview]({{< ref "/docs/applications" >}}) for prerequisites, configuration endpoints, and available scopes.

Install [NextAuth.js](https://next-auth.js.org/):

```bash
npm install next-auth
```

Create the auth configuration in `app/api/auth/[...nextauth]/route.js`:

```javascript
import NextAuth from "next-auth";

const handler = NextAuth({
  providers: [
    {
      id: "vouch",
      name: "Vouch",
      type: "oidc",
      issuer: "https://{{< instance-url >}}",
      clientId: process.env.VOUCH_CLIENT_ID,
      clientSecret: process.env.VOUCH_CLIENT_SECRET,
      authorization: { params: { scope: "openid email" } },
      profile(profile) {
        return {
          id: profile.sub,
          name: profile.name,
          email: profile.email,
        };
      },
    },
  ],
  callbacks: {
    async jwt({ token, account, profile }) {
      if (account) {
        token.accessToken = account.access_token;
        token.vouchId = profile.sub;
      }
      return token;
    },
    async session({ session, token }) {
      session.accessToken = token.accessToken;
      session.user.vouchId = token.vouchId;
      return session;
    },
  },
});

export { handler as GET, handler as POST };
```

Add environment variables to `.env.local`:

```
NEXTAUTH_URL=https://your-app.example.com
NEXTAUTH_SECRET=your-session-secret
VOUCH_CLIENT_ID=your-client-id
VOUCH_CLIENT_SECRET=your-client-secret
```


---

## Laravel (Socialite)

Source: https://vouch.sh/docs/applications/laravel/


> See the [Applications overview]({{< ref "/docs/applications" >}}) for prerequisites, configuration endpoints, and available scopes.

Install the [Socialite](https://laravel.com/docs/socialite) OpenID Connect driver:

```bash
composer require socialiteproviders/openid-connect
```

Add the provider configuration to `config/services.php`:

```php
'vouch' => [
    'client_id' => env('VOUCH_CLIENT_ID'),
    'client_secret' => env('VOUCH_CLIENT_SECRET'),
    'redirect' => env('VOUCH_REDIRECT_URI', 'https://your-app.example.com/auth/vouch/callback'),
    'discovery_url' => 'https://{{< instance-url >}}/.well-known/openid-configuration',
],
```

Register the event listener in `app/Providers/EventServiceProvider.php`:

```php
protected $listen = [
    \SocialiteProviders\Manager\SocialiteWasCalled::class => [
        \SocialiteProviders\OpenIDConnect\OpenIDConnectExtendSocialite::class . '@handle',
    ],
];
```

Add routes in `routes/web.php`:

```php
use Laravel\Socialite\Facades\Socialite;

Route::get('/auth/vouch', function () {
    return Socialite::driver('openid-connect')
        ->setConfig(config('services.vouch'))
        ->scopes(['openid', 'email'])
        ->redirect();
});

Route::get('/auth/vouch/callback', function () {
    $user = Socialite::driver('openid-connect')
        ->setConfig(config('services.vouch'))
        ->user();

    $localUser = User::updateOrCreate(
        ['vouch_id' => $user->getId()],
        [
            'name' => $user->getName(),
            'email' => $user->getEmail(),
        ]
    );

    Auth::login($localUser);
    return redirect('/dashboard');
});
```


---

## Flask (Authlib)

Source: https://vouch.sh/docs/applications/flask/


> See the [Applications overview]({{< ref "/docs/applications" >}}) for prerequisites, configuration endpoints, and available scopes.

Install [Authlib](https://authlib.org/):

```bash
pip install authlib flask
```

Configure the OIDC client in your Flask application:

```python
from flask import Flask, redirect, url_for, session
from authlib.integrations.flask_client import OAuth

app = Flask(__name__)
app.secret_key = os.environ["FLASK_SECRET_KEY"]

oauth = OAuth(app)
vouch = oauth.register(
    name="vouch",
    client_id=os.environ["VOUCH_CLIENT_ID"],
    client_secret=os.environ["VOUCH_CLIENT_SECRET"],
    server_metadata_url="https://{{< instance-url >}}/.well-known/openid-configuration",
    client_kwargs={"scope": "openid email"},
)


@app.route("/login")
def login():
    redirect_uri = url_for("callback", _external=True)
    return vouch.authorize_redirect(redirect_uri)


@app.route("/auth/callback")
def callback():
    token = vouch.authorize_access_token()
    userinfo = token["userinfo"]
    session["user"] = {
        "sub": userinfo["sub"],
        "name": userinfo.get("name"),
        "email": userinfo.get("email"),
    }
    return redirect("/")


@app.route("/")
def index():
    user = session.get("user")
    if user:
        return f"Hello, {user['name']}!"
    return '<a href="/login">Sign in with Vouch</a>'
```


---

## FastAPI (Authlib)

Source: https://vouch.sh/docs/applications/fastapi/


> See the [Applications overview]({{< ref "/docs/applications" >}}) for prerequisites, configuration endpoints, and available scopes.

[Authlib](https://authlib.org/) provides OAuth and OpenID Connect client support for Starlette-based applications.

Install the required packages:

```bash
pip install authlib httpx fastapi uvicorn itsdangerous
```

Configure the OIDC client in your FastAPI application:

```python
import os
from fastapi import FastAPI, Request
from fastapi.responses import RedirectResponse
from authlib.integrations.starlette_client import OAuth
from starlette.middleware.sessions import SessionMiddleware

app = FastAPI()
app.add_middleware(SessionMiddleware, secret_key=os.environ["SESSION_SECRET"])

oauth = OAuth()
oauth.register(
    name="vouch",
    client_id=os.environ["VOUCH_CLIENT_ID"],
    client_secret=os.environ["VOUCH_CLIENT_SECRET"],
    server_metadata_url="https://{{< instance-url >}}/.well-known/openid-configuration",
    client_kwargs={"scope": "openid email"},
)


@app.get("/login")
async def login(request: Request):
    redirect_uri = request.url_for("callback")
    return await oauth.vouch.authorize_redirect(request, redirect_uri)


@app.get("/auth/callback")
async def callback(request: Request):
    token = await oauth.vouch.authorize_access_token(request)
    userinfo = token["userinfo"]
    request.session["user"] = {
        "sub": userinfo["sub"],
        "name": userinfo.get("name"),
        "email": userinfo.get("email"),
    }
    return RedirectResponse(url="/")


@app.get("/")
async def index(request: Request):
    user = request.session.get("user")
    if user:
        return {"message": f"Hello, {user['name']}!"}
    return {"message": "Not authenticated. Visit /login to sign in."}
```


---

## Spring Boot (Spring Security)

Source: https://vouch.sh/docs/applications/spring-boot/


> See the [Applications overview]({{< ref "/docs/applications" >}}) for prerequisites, configuration endpoints, and available scopes.

Add the [Spring Security](https://spring.io/projects/spring-security) OAuth2 Client dependency to your `pom.xml`:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>
```

Configure the OIDC provider in `application.yml`:

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          vouch:
            client-id: ${VOUCH_CLIENT_ID}
            client-secret: ${VOUCH_CLIENT_SECRET}
            scope: openid, email
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/login/oauth2/code/vouch"
        provider:
          vouch:
            issuer-uri: "https://{{< instance-url >}}"
```

Configure Spring Security in your application:

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/", "/login").permitAll()
                .anyRequest().authenticated()
            )
            .oauth2Login(oauth2 -> oauth2
                .defaultSuccessUrl("/dashboard", true)
            );
        return http.build();
    }
}
```

Create a controller to access user information:

```java
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.core.oidc.user.OidcUser;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class DashboardController {

    @GetMapping("/dashboard")
    public String dashboard(@AuthenticationPrincipal OidcUser user, Model model) {
        model.addAttribute("name", user.getFullName());
        model.addAttribute("email", user.getEmail());
        model.addAttribute("sub", user.getSubject());
        return "dashboard";
    }
}
```


---

## Axum (openidconnect-rs)

Source: https://vouch.sh/docs/applications/axum/


> See the [Applications overview]({{< ref "/docs/applications" >}}) for prerequisites, configuration endpoints, and available scopes.

[openidconnect-rs](https://github.com/ramosbugs/openidconnect-rs) provides a type-safe OpenID Connect client for Rust.

Add the required dependencies to your `Cargo.toml`:

```toml
[dependencies]
axum = "0.7"
axum-extra = { version = "0.9", features = ["cookie"] }
openidconnect = "3"
reqwest = { version = "0.12", features = ["rustls-tls"] }
serde = { version = "1", features = ["derive"] }
tokio = { version = "1", features = ["full"] }
tower-sessions = "0.13"
url = "2"
```

Implement the OIDC integration:

```rust
use axum::{
    extract::{Query, State},
    response::{IntoResponse, Redirect},
    routing::get,
    Router,
};
use openidconnect::{
    core::{CoreClient, CoreProviderMetadata, CoreResponseType},
    reqwest::async_http_client,
    AuthenticationFlow, AuthorizationCode, ClientId, ClientSecret,
    CsrfToken, IssuerUrl, Nonce, RedirectUrl, Scope, TokenResponse,
};
use serde::Deserialize;
use std::sync::Arc;
use tower_sessions::{MemoryStore, Session, SessionManagerLayer};

const CSRF_TOKEN_KEY: &str = "csrf_token";
const NONCE_KEY: &str = "nonce";

struct AppState {
    oidc_client: CoreClient,
}

#[derive(Deserialize)]
struct CallbackParams {
    code: String,
    state: String,
}

async fn login(
    State(state): State<Arc<AppState>>,
    session: Session,
) -> impl IntoResponse {
    let (auth_url, csrf_token, nonce) = state
        .oidc_client
        .authorize_url(
            AuthenticationFlow::<CoreResponseType>::AuthorizationCode,
            CsrfToken::new_random,
            Nonce::new_random,
        )
        .add_scope(Scope::new("email".to_string()))
        .url();

    // Store the CSRF token and nonce in the session so we can verify them
    // when the provider redirects back to the callback endpoint.
    session
        .insert(CSRF_TOKEN_KEY, csrf_token.secret().clone())
        .await
        .expect("Failed to store CSRF token");
    session
        .insert(NONCE_KEY, nonce.secret().clone())
        .await
        .expect("Failed to store nonce");

    Redirect::to(auth_url.as_str())
}

async fn callback(
    State(state): State<Arc<AppState>>,
    session: Session,
    Query(params): Query<CallbackParams>,
) -> impl IntoResponse {
    // Retrieve and remove the CSRF token from the session.
    let stored_csrf: String = session
        .remove(CSRF_TOKEN_KEY)
        .await
        .expect("Session error")
        .expect("Missing CSRF token in session -- login flow was not initiated");

    // Verify the state parameter matches the CSRF token we stored.
    if params.state != stored_csrf {
        panic!("CSRF token mismatch -- possible CSRF attack");
    }

    // Retrieve and remove the nonce from the session.
    let stored_nonce: String = session
        .remove(NONCE_KEY)
        .await
        .expect("Session error")
        .expect("Missing nonce in session");
    let nonce = Nonce::new(stored_nonce);

    let token_response = state
        .oidc_client
        .exchange_code(AuthorizationCode::new(params.code))
        .request_async(async_http_client)
        .await
        .expect("Failed to exchange code");

    let id_token = token_response
        .id_token()
        .expect("Server did not return an ID token");

    // Verify the ID token using the nonce from the original authorization request.
    let claims = id_token
        .claims(&state.oidc_client.id_token_verifier(), &nonce)
        .expect("Failed to verify ID token");

    format!(
        "Welcome! Subject: {}, Email: {:?}",
        claims.subject(),
        claims.email()
    )
}

#[tokio::main]
async fn main() {
    let issuer_url =
        IssuerUrl::new("https://{{< instance-url >}}".to_string()).expect("Invalid issuer URL");

    let provider_metadata =
        CoreProviderMetadata::discover_async(issuer_url, async_http_client)
            .await
            .expect("Failed to discover provider");

    let client = CoreClient::from_provider_metadata(
        provider_metadata,
        ClientId::new(std::env::var("VOUCH_CLIENT_ID").expect("VOUCH_CLIENT_ID not set")),
        Some(ClientSecret::new(
            std::env::var("VOUCH_CLIENT_SECRET").expect("VOUCH_CLIENT_SECRET not set"),
        )),
    )
    .set_redirect_uri(
        RedirectUrl::new("https://your-app.example.com/auth/callback".to_string())
            .expect("Invalid redirect URL"),
    );

    let state = Arc::new(AppState {
        oidc_client: client,
    });

    // Use an in-memory session store. In production, replace with a
    // persistent store (e.g., Redis) for multi-instance deployments.
    let session_store = MemoryStore::default();
    let session_layer = SessionManagerLayer::new(session_store);

    let app = Router::new()
        .route("/login", get(login))
        .route("/auth/callback", get(callback))
        .layer(session_layer)
        .with_state(state);

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .expect("Failed to bind");
    axum::serve(listener, app).await.expect("Server error");
}
```


---

## React (react-oidc-context)

Source: https://vouch.sh/docs/applications/react/


> See the [Applications overview]({{< ref "/docs/applications" >}}) for prerequisites, configuration endpoints, and available scopes.

For client-side applications running in the browser, use the authorization code flow with PKCE. These examples do not use a client secret since the code runs in the user's browser.

> **PKCE is required** for browser-based clients. `oidc-client-ts` enables PKCE by default -- no additional configuration is needed. To handle token expiry, enable `automaticSilentRenew` in the OIDC configuration (shown below) so tokens are refreshed transparently before they expire.

[react-oidc-context](https://github.com/authts/react-oidc-context) wraps [`oidc-client-ts`](https://github.com/authts/oidc-client-ts) in a React context provider.

Install the library:

```bash
npm install react-oidc-context oidc-client-ts
```

Configure the OIDC provider in your application:

```jsx
import React from "react";
import ReactDOM from "react-dom/client";
import { AuthProvider, useAuth } from "react-oidc-context";

const oidcConfig = {
  authority: "https://{{< instance-url >}}",
  client_id: "your-client-id",
  redirect_uri: "https://your-app.example.com/callback",
  scope: "openid email",
  response_type: "code",
  automaticSilentRenew: true,
};

function App() {
  const auth = useAuth();

  if (auth.isLoading) {
    return <div>Loading...</div>;
  }

  if (auth.error) {
    return <div>Error: {auth.error.message}</div>;
  }

  if (auth.isAuthenticated) {
    return (
      <div>
        <h1>Welcome, {auth.user?.profile.name}</h1>
        <p>Email: {auth.user?.profile.email}</p>
        <p>Subject: {auth.user?.profile.sub}</p>
        <button onClick={() => auth.removeUser()}>Sign out</button>
      </div>
    );
  }

  return (
    <div>
      <h1>My Application</h1>
      <button onClick={() => auth.signinRedirect()}>Sign in with Vouch</button>
    </div>
  );
}

function CallbackPage() {
  const auth = useAuth();

  React.useEffect(() => {
    if (!auth.isLoading && !auth.isAuthenticated) {
      auth.signinRedirect();
    }
  }, [auth]);

  return <div>Processing login...</div>;
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <AuthProvider {...oidcConfig}>
    <App />
  </AuthProvider>
);
```


---

## Vue (oidc-client-ts)

Source: https://vouch.sh/docs/applications/vue/


> See the [Applications overview]({{< ref "/docs/applications" >}}) for prerequisites, configuration endpoints, and available scopes.

For client-side applications running in the browser, use the authorization code flow with PKCE. These examples do not use a client secret since the code runs in the user's browser.

> **PKCE is required** for browser-based clients. `oidc-client-ts` enables PKCE by default -- no additional configuration is needed. To handle token expiry, enable `automaticSilentRenew` in the UserManager configuration (shown below) so tokens are refreshed transparently before they expire.

[oidc-client-ts](https://github.com/authts/oidc-client-ts) provides a certified OpenID Connect client for browser-based applications.

Install the library:

```bash
npm install oidc-client-ts
```

Create an auth service in `src/auth.js`:

```javascript
import { UserManager, WebStorageStateStore } from "oidc-client-ts";

const userManager = new UserManager({
  authority: "https://{{< instance-url >}}",
  client_id: "your-client-id",
  redirect_uri: "https://your-app.example.com/callback",
  scope: "openid email",
  response_type: "code",
  automaticSilentRenew: true,
  userStore: new WebStorageStateStore({ store: window.localStorage }),
});

export async function login() {
  await userManager.signinRedirect();
}

export async function handleCallback() {
  return await userManager.signinRedirectCallback();
}

export async function getUser() {
  return await userManager.getUser();
}

export async function logout() {
  await userManager.removeUser();
}

export default userManager;
```

Use it in a Vue component (`src/App.vue`):

```vue
<template>
  <div>
    <div v-if="loading">Loading...</div>
    <div v-else-if="user">
      <h1>Welcome, {{ user.profile.name }}</h1>
      <p>Email: {{ user.profile.email }}</p>
      <button @click="handleLogout">Sign out</button>
    </div>
    <div v-else>
      <h1>My Application</h1>
      <button @click="handleLogin">Sign in with Vouch</button>
    </div>
  </div>
</template>

<script>
import { login, getUser, logout } from "./auth";

export default {
  data() {
    return {
      user: null,
      loading: true,
    };
  },
  async mounted() {
    try {
      this.user = await getUser();
    } catch (e) {
      console.error("Failed to get user:", e);
    } finally {
      this.loading = false;
    }
  },
  methods: {
    handleLogin() {
      login();
    },
    async handleLogout() {
      await logout();
      this.user = null;
    },
  },
};
</script>
```

Create a callback page (`src/Callback.vue`):

```vue
<template>
  <div>Processing login...</div>
</template>

<script>
import { handleCallback } from "./auth";

export default {
  async mounted() {
    try {
      await handleCallback();
      this.$router.push("/");
    } catch (e) {
      console.error("Callback error:", e);
      this.$router.push("/login");
    }
  },
};
</script>
```


---

## Vanilla JavaScript

Source: https://vouch.sh/docs/applications/vanilla-js/


> See the [Applications overview]({{< ref "/docs/applications" >}}) for prerequisites, configuration endpoints, and available scopes.

For client-side applications running in the browser, use the authorization code flow with PKCE. These examples do not use a client secret since the code runs in the user's browser.

> **PKCE is required** for browser-based clients. `oidc-client-ts` enables PKCE by default -- no additional configuration is needed. To handle token expiry, enable `automaticSilentRenew` in the UserManager configuration (shown below) so tokens are refreshed transparently before they expire.

For applications without a framework, use [`oidc-client-ts`](https://github.com/authts/oidc-client-ts) directly:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Vouch OIDC Example</title>
</head>
<body>
  <div id="app">
    <div id="loading">Loading...</div>
    <div id="authenticated" style="display: none">
      <h1>Welcome, <span id="user-name"></span></h1>
      <p>Email: <span id="user-email"></span></p>
      <button id="logout-btn">Sign out</button>
    </div>
    <div id="unauthenticated" style="display: none">
      <h1>My Application</h1>
      <button id="login-btn">Sign in with Vouch</button>
    </div>
  </div>

  <script type="module">
    import { UserManager } from "https://cdn.jsdelivr.net/npm/oidc-client-ts/dist/browser/oidc-client-ts.min.js";

    const config = {
      authority: "https://{{< instance-url >}}",
      client_id: "your-client-id",
      redirect_uri: window.location.origin + "/callback",
      scope: "openid email",
      response_type: "code",
      automaticSilentRenew: true,
    };

    const userManager = new UserManager(config);

    async function init() {
      // Handle callback
      if (window.location.pathname === "/callback") {
        try {
          await userManager.signinRedirectCallback();
          window.location.href = "/";
        } catch (e) {
          console.error("Callback error:", e);
        }
        return;
      }

      // Check for existing session
      const user = await userManager.getUser();
      document.getElementById("loading").style.display = "none";

      if (user && !user.expired) {
        document.getElementById("user-name").textContent = user.profile.name;
        document.getElementById("user-email").textContent = user.profile.email;
        document.getElementById("authenticated").style.display = "block";
      } else {
        document.getElementById("unauthenticated").style.display = "block";
      }
    }

    document.getElementById("login-btn")?.addEventListener("click", () => {
      userManager.signinRedirect();
    });

    document.getElementById("logout-btn")?.addEventListener("click", async () => {
      await userManager.removeUser();
      window.location.href = "/";
    });

    init();
  </script>
</body>
</html>
```


---

## Device Authorization (CLI)

Source: https://vouch.sh/docs/applications/device-authorization/


> See the [Applications overview]({{< ref "/docs/applications" >}}) for prerequisites, configuration endpoints, and available scopes.

For native desktop applications and CLI tools that cannot open a browser redirect, use the **Device Authorization Grant** ([RFC 8628](https://datatracker.ietf.org/doc/html/rfc8628)). This flow displays a URL and code that the user enters in a browser on any device.

## Device Authorization Flow

1. Your application requests a device code from the Vouch server.
2. The server returns a `device_code`, a `user_code`, and a `verification_uri`.
3. Your application displays the `user_code` and `verification_uri` to the user.
4. The user opens `verification_uri` in a browser, enters the code, and authenticates with their YubiKey.
5. Your application polls the token endpoint until the user completes authentication.
6. Once approved, the token endpoint returns an access token and ID token.

## Python

```python
import os
import time
import requests

VOUCH_URL = "https://{{< instance-url >}}"
CLIENT_ID = os.environ["VOUCH_CLIENT_ID"]

# Step 1: Request device code
device_response = requests.post(
    f"{VOUCH_URL}/oauth/device/code",
    data={
        "client_id": CLIENT_ID,
        "scope": "openid email",
    },
)
device_data = device_response.json()

device_code = device_data["device_code"]
user_code = device_data["user_code"]
verification_uri = device_data["verification_uri"]
interval = device_data.get("interval", 5)
expires_in = device_data.get("expires_in", 600)

# Step 2: Display instructions to the user
print(f"\nTo sign in, open this URL in your browser:\n")
print(f"  {verification_uri}\n")
print(f"And enter the code: {user_code}\n")
print("Waiting for authentication...")

# Step 3: Poll for the token
deadline = time.time() + expires_in
while time.time() < deadline:
    time.sleep(interval)

    token_response = requests.post(
        f"{VOUCH_URL}/oauth/token",
        data={
            "grant_type": "urn:ietf:params:oauth:grant-type:device_code",
            "device_code": device_code,
            "client_id": CLIENT_ID,
        },
    )

    if token_response.status_code == 200:
        tokens = token_response.json()
        print(f"\nAuthenticated successfully!")
        print(f"Access token: {tokens['access_token'][:20]}...")

        # Fetch user info
        userinfo = requests.get(
            f"{VOUCH_URL}/oauth/userinfo",
            headers={"Authorization": f"Bearer {tokens['access_token']}"},
        ).json()
        print(f"Hello, {userinfo.get('name', 'user')}!")
        break

    error_data = token_response.json()
    error = error_data.get("error")

    if error == "authorization_pending":
        continue
    elif error == "slow_down":
        interval += 5
        continue
    elif error == "expired_token":
        print("The device code has expired. Please try again.")
        break
    elif error == "access_denied":
        print("Authentication was denied.")
        break
    else:
        print(f"Unexpected error: {error}")
        break
else:
    print("Timed out waiting for authentication.")
```

## Node.js

```javascript
const https = require("https");
const querystring = require("querystring");

const VOUCH_URL = "https://{{< instance-url >}}";
const CLIENT_ID = process.env.VOUCH_CLIENT_ID;

function post(path, data) {
  return new Promise((resolve, reject) => {
    const url = new URL(path, VOUCH_URL);
    const body = querystring.stringify(data);
    const req = https.request(
      url,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          "Content-Length": Buffer.byteLength(body),
        },
      },
      (res) => {
        let data = "";
        res.on("data", (chunk) => (data += chunk));
        res.on("end", () =>
          resolve({ status: res.statusCode, body: JSON.parse(data) })
        );
      }
    );
    req.on("error", reject);
    req.write(body);
    req.end();
  });
}

function get(path, token) {
  return new Promise((resolve, reject) => {
    const url = new URL(path, VOUCH_URL);
    const req = https.request(
      url,
      {
        method: "GET",
        headers: { Authorization: `Bearer ${token}` },
      },
      (res) => {
        let data = "";
        res.on("data", (chunk) => (data += chunk));
        res.on("end", () => resolve(JSON.parse(data)));
      }
    );
    req.on("error", reject);
    req.end();
  });
}

async function main() {
  // Step 1: Request device code
  const deviceResponse = await post("/oauth/device/code", {
    client_id: CLIENT_ID,
    scope: "openid email",
  });

  const { device_code, user_code, verification_uri, interval = 5, expires_in = 600 } =
    deviceResponse.body;

  // Step 2: Display instructions
  console.log(`\nTo sign in, open this URL in your browser:\n`);
  console.log(`  ${verification_uri}\n`);
  console.log(`And enter the code: ${user_code}\n`);
  console.log("Waiting for authentication...");

  // Step 3: Poll for the token
  let pollInterval = interval;
  const deadline = Date.now() + expires_in * 1000;

  while (Date.now() < deadline) {
    await new Promise((r) => setTimeout(r, pollInterval * 1000));

    const tokenResponse = await post("/oauth/token", {
      grant_type: "urn:ietf:params:oauth:grant-type:device_code",
      device_code,
      client_id: CLIENT_ID,
    });

    if (tokenResponse.status === 200) {
      console.log("\nAuthenticated successfully!");

      const userinfo = await get("/oauth/userinfo", tokenResponse.body.access_token);
      console.log(`Hello, ${userinfo.name || "user"}!`);
      return;
    }

    const error = tokenResponse.body.error;

    if (error === "authorization_pending") continue;
    if (error === "slow_down") {
      pollInterval += 5;
      continue;
    }
    if (error === "expired_token") {
      console.log("The device code has expired. Please try again.");
      return;
    }
    if (error === "access_denied") {
      console.log("Authentication was denied.");
      return;
    }

    console.log(`Unexpected error: ${error}`);
    return;
  }

  console.log("Timed out waiting for authentication.");
}

main().catch(console.error);
```

## Rust

Add the required dependencies to your `Cargo.toml`:

```toml
[dependencies]
reqwest = { version = "0.12", features = ["json"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
tokio = { version = "1", features = ["full"] }
```

Implement the device authorization flow:

```rust
use serde::Deserialize;
use std::env;
use std::time::{Duration, Instant};

#[derive(Deserialize)]
struct DeviceCodeResponse {
    device_code: String,
    user_code: String,
    verification_uri: String,
    #[serde(default = "default_interval")]
    interval: u64,
    #[serde(default = "default_expires_in")]
    expires_in: u64,
}

fn default_interval() -> u64 { 5 }
fn default_expires_in() -> u64 { 600 }

#[derive(Deserialize)]
struct TokenResponse {
    access_token: String,
}

#[derive(Deserialize)]
struct ErrorResponse {
    error: String,
}

#[derive(Deserialize)]
struct UserInfo {
    name: Option<String>,
    email: Option<String>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let vouch_url = "https://{{< instance-url >}}";
    let client_id = env::var("VOUCH_CLIENT_ID")
        .expect("VOUCH_CLIENT_ID environment variable not set");

    let client = reqwest::Client::new();

    // Step 1: Request device code
    let device_response: DeviceCodeResponse = client
        .post(format!("{vouch_url}/oauth/device/code"))
        .form(&[
            ("client_id", client_id.as_str()),
            ("scope", "openid email"),
        ])
        .send()
        .await?
        .json()
        .await?;

    // Step 2: Display instructions
    println!("\nTo sign in, open this URL in your browser:\n");
    println!("  {}\n", device_response.verification_uri);
    println!("And enter the code: {}\n", device_response.user_code);
    println!("Waiting for authentication...");

    // Step 3: Poll for the token
    let mut interval = Duration::from_secs(device_response.interval);
    let deadline = Instant::now() + Duration::from_secs(device_response.expires_in);

    loop {
        tokio::time::sleep(interval).await;

        if Instant::now() > deadline {
            println!("Timed out waiting for authentication.");
            break;
        }

        let response = client
            .post(format!("{vouch_url}/oauth/token"))
            .form(&[
                ("grant_type", "urn:ietf:params:oauth:grant-type:device_code"),
                ("device_code", &device_response.device_code),
                ("client_id", &client_id),
            ])
            .send()
            .await?;

        if response.status().is_success() {
            let tokens: TokenResponse = response.json().await?;
            println!("\nAuthenticated successfully!");

            let userinfo: UserInfo = client
                .get(format!("{vouch_url}/oauth/userinfo"))
                .bearer_auth(&tokens.access_token)
                .send()
                .await?
                .json()
                .await?;

            println!(
                "Hello, {}!",
                userinfo.name.unwrap_or_else(|| "user".to_string())
            );
            break;
        }

        let error: ErrorResponse = response.json().await?;
        match error.error.as_str() {
            "authorization_pending" => continue,
            "slow_down" => {
                interval += Duration::from_secs(5);
                continue;
            }
            "expired_token" => {
                println!("The device code has expired. Please try again.");
                break;
            }
            "access_denied" => {
                println!("Authentication was denied.");
                break;
            }
            other => {
                println!("Unexpected error: {other}");
                break;
            }
        }
    }

    Ok(())
}
```

---

## Device Authorization Response

When your application requests a device code, the server returns the following fields:

| Field | Type | Description |
|---|---|---|
| `device_code` | string | The device verification code. Used by your application when polling the token endpoint. Do not display this to the user. |
| `user_code` | string | The end-user verification code. Display this to the user so they can enter it in their browser. |
| `verification_uri` | string | The URL the user should visit to enter the code and authenticate. |
| `verification_uri_complete` | string | Optional. A URL that includes the `user_code`, so the user can navigate directly without manually entering the code. |
| `expires_in` | number | The lifetime of the `device_code` and `user_code` in seconds. |
| `interval` | number | The minimum number of seconds your application should wait between polling requests. |

---

## Polling Errors

When polling the token endpoint during the device authorization flow, the server may return the following error codes:

| Error | Description | Action |
|---|---|---|
| `authorization_pending` | The user has not yet completed authentication. | Continue polling at the specified interval. |
| `slow_down` | Your application is polling too frequently. | Increase the polling interval by 5 seconds and continue. |
| `expired_token` | The `device_code` has expired. | Stop polling. Restart the flow by requesting a new device code. |
| `access_denied` | The user denied the authorization request. | Stop polling. Inform the user that authentication was denied. |



---

# Automate User Provisioning with SCIM

Source: https://vouch.sh/docs/scim/


Manually adding and removing users from Vouch when people join or leave your organization is error-prone and easy to forget. A missed offboarding means someone retains access to hardware-backed credentials they should no longer have.

SCIM (System for Cross-domain Identity Management) lets your identity provider -- Google Workspace, Okta, Azure AD, or OneLogin -- handle this automatically in real time. Vouch supports the **SCIM 2.0** protocol ([RFC 7644](https://datatracker.ietf.org/doc/html/rfc7644)) for automated user provisioning and de-provisioning. When SCIM is configured, your identity provider (IdP) can automatically:

- **Create** new Vouch user accounts when people join your organization.
- **Update** user attributes (name, email, role) when they change in your directory.
- **Deactivate** accounts instantly when someone leaves or changes roles.

This eliminates manual user management and ensures that credential access is always in sync with your corporate directory.

---

## How It Works

1. You generate a SCIM bearer token from the Vouch server.
2. You configure your identity provider to point at Vouch's SCIM 2.0 endpoint.
3. The IdP pushes user lifecycle events (create, update, deactivate) to Vouch in real time.
4. Vouch processes each event and updates its internal user directory accordingly.

Because SCIM is a standardized protocol, Vouch works with any identity provider that supports SCIM 2.0 -- including Google Workspace, Okta, Azure AD (Entra ID), and OneLogin.

---

## Step 1 -- Generate a SCIM Token

Before your identity provider can communicate with Vouch, you need to generate a bearer token that the IdP will use to authenticate its requests.

First, ensure you are logged in with an account that has **organization administrator** privileges:

```bash
vouch login
```

Then create a SCIM token:

```bash
curl -X POST https://{{< instance-url >}}/api/v1/org/scim-tokens \
  -b ~/.vouch/cookie.txt \
  -H "Content-Type: application/json" \
  -d '{"description": "Google Workspace SCIM", "expires_in_days": 365}'
```

The response includes the plaintext token:

```json
{
  "id": "scim_tok_abc123",
  "description": "Google Workspace SCIM",
  "token": "vouch_scim_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
  "expires_at": "2027-01-15T00:00:00Z",
  "created_at": "2026-01-15T12:00:00Z"
}
```

> **Security note:** Vouch stores only a cryptographic hash of the token. The plaintext value is shown **exactly once** in the creation response. Copy it immediately and store it securely -- you will not be able to retrieve it again. If you lose the token, revoke it and create a new one.

The `expires_in_days` field is **required** and must be an integer between **1** and **365**. Choose an expiration period that balances security with operational convenience. Most organizations use 365 days and rotate tokens annually.

---

## Step 2 -- Configure Your Identity Provider

Use the following values when configuring SCIM in your identity provider:

| Setting | Value |
|---|---|
| **SCIM Base URL** | `https://{{< instance-url >}}/scim/v2` |
| **Authentication Type** | Bearer Token |
| **Authorization Header** | `Bearer vouch_scim_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx` |

Replace the token value with the plaintext token you received in Step 1.

### Google Workspace

1. Open the [Google Admin Console](https://admin.google.com).
2. Navigate to **Apps > Web and mobile apps**.
3. Find or add the Vouch application.
4. Open the **Auto-provisioning** section.
5. Set the **SCIM Base URL** to `https://{{< instance-url >}}/scim/v2`.
6. Set the **Authentication Type** to **Bearer Token** and paste your SCIM token.
7. Click **Test Connection** to verify.
8. Enable auto-provisioning and configure the desired attribute mappings.
9. Click **Save**.

### Okta

1. Open the Okta Admin Dashboard.
2. Navigate to **Applications > Applications**.
3. Select or create the Vouch application.
4. Go to the **Provisioning** tab and click **Configure API Integration**.
5. Check **Enable API Integration**.
6. Set the **SCIM 2.0 Base URL** to `https://{{< instance-url >}}/scim/v2`.
7. Set the **API Token** to the SCIM bearer token from Step 1.
8. Click **Test API Credentials** to verify connectivity.
9. Click **Save**.
10. Under **Provisioning > To App**, enable the desired actions: **Create Users**, **Update User Attributes**, and **Deactivate Users**.

### Azure AD (Entra ID)

1. Open the [Azure Portal](https://portal.azure.com) and navigate to **Azure Active Directory > Enterprise Applications**.
2. Select or create the Vouch application.
3. Go to **Provisioning** and set the **Provisioning Mode** to **Automatic**.
4. Under **Admin Credentials**:
   - Set **Tenant URL** to `https://{{< instance-url >}}/scim/v2`.
   - Set **Secret Token** to the SCIM bearer token from Step 1.
5. Click **Test Connection** to verify that Azure can reach the Vouch SCIM endpoint.
6. Configure attribute mappings under **Mappings** to align Azure AD attributes with Vouch user fields.
7. Set **Provisioning Status** to **On**.
8. Click **Save** to begin provisioning.

### OneLogin

1. Open the OneLogin Admin Panel.
2. Navigate to **Applications > Applications**.
3. Select or create the Vouch application.
4. Go to the **Provisioning** tab.
5. Enable provisioning and set the **SCIM Base URL** to `https://{{< instance-url >}}/scim/v2`.
6. Set the **SCIM Bearer Token** to the token from Step 1.
7. Under **Provisioning Actions**, enable **Create user**, **Update user**, and **Delete user**.
8. Click **Save**.

---

## Step 3 -- Test the Integration

After configuring your identity provider, verify that the SCIM connection is working correctly by querying the Vouch SCIM endpoints directly.

### Check the Service Provider Configuration

This endpoint returns the SCIM capabilities supported by Vouch:

```bash
curl -s https://{{< instance-url >}}/scim/v2/ServiceProviderConfig \
  -H "Authorization: Bearer vouch_scim_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" \
  | jq .
```

A successful response returns a JSON object describing the supported SCIM features, including authentication schemes, bulk support, and filtering capabilities.

### List Provisioned Users

Retrieve the list of users that have been provisioned through SCIM:

```bash
curl -s https://{{< instance-url >}}/scim/v2/Users \
  -H "Authorization: Bearer vouch_scim_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" \
  | jq .
```

This returns a `ListResponse` containing all SCIM-managed users and their attributes.

### List Provisioned Groups

Retrieve the list of groups that have been provisioned through SCIM:

```bash
curl -s https://{{< instance-url >}}/scim/v2/Groups \
  -H "Authorization: Bearer vouch_scim_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" \
  | jq .
```

This returns a `ListResponse` containing all SCIM-managed groups and their membership information.

---

## SCIM 2.0 Endpoints

Vouch implements the following SCIM 2.0 endpoints:

| Method | Endpoint | Description |
|---|---|---|
| `GET` | `/scim/v2/ServiceProviderConfig` | Returns the SCIM service provider configuration and supported features. |
| `GET` | `/scim/v2/ResourceTypes` | Lists the resource types (Users, Groups) supported by the server. |
| `GET` | `/scim/v2/Schemas` | Returns the full SCIM schemas supported by the server. |
| `GET` | `/scim/v2/Users` | Lists all provisioned users. Supports filtering and pagination. |
| `POST` | `/scim/v2/Users` | Creates a new user account. |
| `GET` | `/scim/v2/Users/{id}` | Retrieves a specific user by their SCIM ID. |
| `PUT` | `/scim/v2/Users/{id}` | Replaces all attributes of a specific user. |
| `PATCH` | `/scim/v2/Users/{id}` | Updates specific attributes of a user (partial update). |
| `DELETE` | `/scim/v2/Users/{id}` | Deactivates (soft-deletes) a user account. |
| `GET` | `/scim/v2/Groups` | Lists all provisioned groups. Supports filtering and pagination. |
| `POST` | `/scim/v2/Groups` | Creates a new group. |
| `GET` | `/scim/v2/Groups/{id}` | Retrieves a specific group by its SCIM ID. |
| `PUT` | `/scim/v2/Groups/{id}` | Replaces all attributes of a specific group. |
| `PATCH` | `/scim/v2/Groups/{id}` | Updates specific attributes of a group (partial update). |
| `DELETE` | `/scim/v2/Groups/{id}` | Deletes a group. |

All endpoints require a valid SCIM bearer token in the `Authorization` header. Filtering is supported on the `Users` and `Groups` list endpoints using the SCIM filter syntax (e.g., `?filter=userName eq "alice@example.com"`).

---

## Immediate De-provisioning

One of the most important benefits of SCIM integration is **immediate de-provisioning**. When an employee leaves your organization or changes roles:

1. Your identity provider sends a `PATCH` or `DELETE` request to the Vouch SCIM endpoint to deactivate the user.
2. Vouch immediately marks the user account as inactive.
3. All **active sessions** for that user are revoked instantly.
4. The user can no longer obtain new credentials. Previously issued short-lived credentials (SSH certificates, AWS STS credentials) will continue to function until their natural expiration (up to 8 hours). No new credentials can be issued after de-provisioning.

Because all Vouch credentials are short-lived (maximum 8 hours), the exposure window after de-provisioning is limited. Sessions are revoked immediately, and outstanding credentials expire on their own shortly after.

This is a significant security improvement over traditional provisioning workflows where revoking access requires manual steps across multiple systems. With Vouch and SCIM, de-provisioning is automated and the blast radius is minimized by the short credential lifetime.

---

## Managing SCIM Tokens

Organization administrators can list, create, and revoke SCIM tokens through the Vouch API.

### List All SCIM Tokens

Retrieve all active SCIM tokens for your organization:

```bash
curl -s https://{{< instance-url >}}/api/v1/org/scim-tokens \
  -b ~/.vouch/cookie.txt \
  | jq .
```

The response includes token metadata (ID, description, creation date, expiration date) but never the plaintext token value.

### Create a New Token

```bash
curl -X POST https://{{< instance-url >}}/api/v1/org/scim-tokens \
  -b ~/.vouch/cookie.txt \
  -H "Content-Type: application/json" \
  -d '{"description": "Okta SCIM Integration", "expires_in_days": 180}'
```

The response includes the plaintext token. Store it securely -- it will not be shown again.

### Revoke a Token

Revoke a SCIM token by its ID to immediately disable it:

```bash
curl -X DELETE https://{{< instance-url >}}/api/v1/org/scim-tokens/scim_tok_abc123 \
  -b ~/.vouch/cookie.txt
```

After revocation, any identity provider using this token will receive `401 Unauthorized` responses and provisioning will stop until a new token is configured.

---

## Rotating SCIM Tokens

To rotate a SCIM token without interrupting provisioning, follow this four-step process:

1. **Create a new token** with a descriptive name that indicates it is the replacement:

   ```bash
   curl -X POST https://{{< instance-url >}}/api/v1/org/scim-tokens \
     -b ~/.vouch/cookie.txt \
     -H "Content-Type: application/json" \
     -d '{"description": "Google Workspace SCIM (rotated 2026-02)", "expires_in_days": 365}'
   ```

2. **Update your identity provider** with the new token value. Follow the configuration steps for your IdP described in Step 2 above, replacing the old token with the new one.

3. **Test the new token** by triggering a sync from your identity provider or by querying the SCIM endpoint directly with the new token:

   ```bash
   curl -s https://{{< instance-url >}}/scim/v2/Users \
     -H "Authorization: Bearer vouch_scim_NEW_TOKEN_HERE" \
     | jq '.totalResults'
   ```

4. **Revoke the old token** once you have confirmed that the new token is working:

   ```bash
   curl -X DELETE {{< instance-url >}}/api/v1/org/scim-tokens/scim_tok_OLD_ID \
     -b ~/.vouch/cookie.txt
   ```

By creating the new token before revoking the old one, you ensure there is no window during which provisioning is interrupted.

---

## Troubleshooting

### 401 Unauthorized

The SCIM token is invalid, expired, or revoked.

- Verify the token has not expired by listing your active tokens.
- Ensure the `Authorization` header uses the format `Bearer <token>` with no extra whitespace or characters.
- If the token was recently created, confirm you copied the full plaintext value -- it is only shown once during creation.
- If the token has expired or been revoked, create a new token and update your identity provider configuration.

### 409 Conflict

A user or group with the same unique identifier already exists.

- This typically occurs when your identity provider attempts to create a user who has already been provisioned, either through a previous SCIM sync or through manual registration.
- Check whether the user already exists in Vouch by querying the Users endpoint with a filter:

  ```bash
  curl -s "https://{{< instance-url >}}/scim/v2/Users?filter=userName%20eq%20%22alice%40example.com%22" \
    -H "Authorization: Bearer vouch_scim_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" \
    | jq .
  ```

- If the user exists, your IdP should use `PUT` or `PATCH` to update the existing record rather than `POST` to create a new one. Most identity providers handle this automatically after the initial conflict.

### Users Not Syncing

If users are not appearing in Vouch after configuring SCIM:

- **Verify the SCIM Base URL.** Ensure it is set to `https://{{< instance-url >}}/scim/v2` with no trailing slash.
- **Test connectivity.** Use the `ServiceProviderConfig` endpoint to confirm the IdP can reach Vouch:

  ```bash
  curl -s https://{{< instance-url >}}/scim/v2/ServiceProviderConfig \
    -H "Authorization: Bearer vouch_scim_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" \
    | jq .
  ```

- **Check your IdP's provisioning logs.** Most identity providers maintain a log of SCIM operations and any errors encountered. Look for HTTP error codes or timeout messages.
- **Confirm provisioning is enabled.** In some IdPs (especially Okta and Azure AD), you must explicitly enable provisioning actions (Create, Update, Deactivate) after configuring the API connection.
- **Verify user assignment.** In many IdPs, users must be explicitly assigned to the Vouch application before they will be provisioned. Check that the intended users or groups are assigned.

### Attribute Mapping Issues

If user attributes (name, email, department) are not appearing correctly in Vouch:

- Review the attribute mappings in your identity provider's SCIM configuration.
- Vouch expects the standard SCIM 2.0 `User` schema attributes:
  - `userName` -- The user's email address (used as the unique identifier).
  - `name.givenName` -- The user's first name.
  - `name.familyName` -- The user's last name.
  - `emails` -- An array of email objects; the `primary` email is used for notifications.
  - `active` -- A boolean indicating whether the account is active.
- Ensure your IdP is mapping its directory attributes to these standard SCIM fields.



---

# Connect to EC2 Instances without SSH Port 22

Source: https://vouch.sh/docs/ssm/


Managing SSH access to EC2 instances typically means opening port 22, distributing keys, and maintaining security groups. Every open port is an attack surface, and every key is a secret to manage.

AWS Systems Manager Session Manager eliminates all of this: connections go through the Systems Manager service, every session is logged in CloudTrail, and no inbound ports are required. With Vouch, the underlying AWS credentials are hardware-verified and short-lived -- after `vouch login`, you can start sessions to any SSM-managed instance.

## How it works

1. **`vouch login`** -- The developer authenticates with their YubiKey and receives an OIDC ID token.
2. **`credential_process`** -- The AWS CLI calls Vouch to exchange the OIDC token for temporary STS credentials.
3. **`aws ssm start-session`** -- The AWS CLI uses the STS credentials to start an AWS SSM Session Manager session with the target instance.
4. **CloudTrail** -- Every session start is recorded with the Vouch user's identity via STS session tags.

```
vouch login → credential_process → STS → AWS SSM start-session → CloudTrail
```

---

## Prerequisites

Before using AWS Systems Manager Session Manager with Vouch, ensure you have:

- The **Vouch CLI** installed and enrolled (see [Getting Started](/docs/getting-started/))
- The **[AWS integration](/docs/aws/)** configured (OIDC provider and IAM role)
- The **[Session Manager plugin](https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-install-plugin.html)** installed for the AWS CLI
- EC2 instances with the **AWS SSM Agent** installed and an instance profile that allows AWS SSM connections

---

## Step 1 -- Start a session

With an active Vouch session, connect to an instance:

```bash
aws ssm start-session \
  --target i-0abc123def456 \
  --profile vouch
```

This opens an interactive shell session on the target instance without SSH.

---

## Step 2 -- SSH over AWS SSM

You can also use AWS SSM as a transport for standard SSH connections. This lets you use familiar SSH tooling (scp, rsync, port forwarding) while routing traffic through AWS SSM instead of direct TCP connections.

### Automated setup (recommended)

The `vouch setup ssm` command configures your SSH client automatically:

```bash
vouch setup ssm
```

| Flag | Description |
|---|---|
| `--profile` | AWS profile to use (defaults to auto-detected vouch profile) |
| `--region` | AWS region to use in the ProxyCommand |
| `--hosts` | Host patterns to match (default: `i-* mi-*`) |
| `--force` | Overwrite any existing SSM configuration in `~/.ssh/config` |

To specify a profile and region explicitly:

```bash
vouch setup ssm --profile vouch --region us-east-1
```

This adds the following to your `~/.ssh/config`:

```
Host i-* mi-*
    ProxyCommand sh -c "aws ssm start-session --target %h --document-name AWS-StartSSHSession --parameters 'portNumber=%p' --profile vouch --region us-east-1"
```

### Manual setup

Alternatively, add the following to your `~/.ssh/config` manually:

```
Host i-* mi-*
    ProxyCommand sh -c "aws ssm start-session --target %h --document-name AWS-StartSSHSession --parameters 'portNumber=%p' --profile vouch --region <YOUR_REGION>"
```

Replace `<YOUR_REGION>` with your AWS region (e.g., `us-east-1`).

### Connect

With either setup method, connect with SSH as usual:

```bash
ssh i-0abc123def456
```

Because Vouch configures the SSH agent with a certificate, the SSH session is authenticated with both your Vouch SSH certificate and your hardware-backed AWS credentials.

---

## Port forwarding

AWS SSM supports port forwarding to access services on private instances. This is useful for reaching databases (such as RDS) through a bastion instance without exposing them to the internet:

```bash
# Forward local port 5432 to an RDS instance through an EC2 bastion
aws ssm start-session \
  --target i-0abc123def456 \
  --document-name AWS-StartPortForwardingSessionToRemoteHost \
  --parameters '{"host":["mydb.cluster-abc123.us-east-1.rds.amazonaws.com"],"portNumber":["5432"],"localPortNumber":["5432"]}' \
  --profile vouch
```

Then connect to `localhost:5432` with your database client.

---

## IAM permissions

The IAM role assumed by Vouch needs AWS SSM session permissions:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "ssm:StartSession",
        "ssm:TerminateSession",
        "ssm:ResumeSession"
      ],
      "Resource": [
        "arn:aws:ec2:us-east-1:123456789012:instance/*",
        "arn:aws:ssm:us-east-1::document/AWS-StartSSHSession",
        "arn:aws:ssm:us-east-1::document/AWS-StartPortForwardingSessionToRemoteHost"
      ]
    }
  ]
}
```

You can restrict access to specific instances using resource ARNs or tag-based conditions.

---

## Session identity and audit

When Vouch exchanges an OIDC token for STS credentials, the user's email and domain are embedded as session tags. These appear in CloudTrail under `userIdentity.sessionContext.webIdFederationData`, providing a clear chain from YubiKey tap to AWS SSM session.

AWS SSM also records session activity. With [Session Manager logging](https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-logging.html) enabled, you get a complete record of commands executed during each session.

---

## Troubleshooting

### "SessionManagerPlugin is not found"

The Session Manager plugin is not installed or not in your PATH. Install it from the [AWS documentation](https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager-working-with-install-plugin.html).

### "TargetNotConnected"

The target instance does not have a running AWS SSM agent or cannot reach the AWS Systems Manager endpoint. Verify:

- The instance has an IAM instance profile with `AmazonSSMManagedInstanceCore` permissions.
- The AWS SSM agent is running: `sudo systemctl status amazon-ssm-agent`.
- The instance can reach the AWS SSM endpoint (either through a NAT gateway or VPC endpoint).

### "Access denied" when starting a session

- Verify your IAM role has `ssm:StartSession` permission for the target instance.
- Check that the instance ARN matches the resource constraints in your IAM policy.
- Ensure you have an active Vouch session: `vouch login`.

### `vouch setup ssm` reports existing SSM configuration

If the command detects an existing SSM block in your `~/.ssh/config`, it will not overwrite it by default. Use the `--force` flag to replace the existing configuration:

```bash
vouch setup ssm --force
```

### `vouch doctor` reports SSM issues

Run `vouch doctor` to diagnose SSM configuration problems. If issues are found, run `vouch setup ssm` to reconfigure your SSH client automatically.



---

# Connect to RDS and Aurora without Database Passwords

Source: https://vouch.sh/docs/databases/


Static database passwords are shared across developers, stored in configuration files, and rarely rotated. When someone leaves the team, do you rotate every database password they had access to? Most teams don't.

[IAM database authentication](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.IAMDBAuth.html) replaces static passwords with 15-minute tokens generated from IAM credentials. With Vouch, those IAM credentials are themselves hardware-backed and short-lived -- every database connection traces back to a verified human identity.

## How it works

1. **`vouch login`** -- The developer authenticates with their YubiKey.
2. **`vouch credential rds`** or **`vouch credential redshift`** -- Vouch generates a short-lived database authentication token or temporary credentials directly.
3. **Database client** -- The token is passed as the password to `psql`, `mysql`, or another database client.

```
vouch login → vouch credential rds → database client
vouch login → vouch credential redshift → database client
```

Or use `vouch exec` to skip manual token handling entirely:

```
vouch login → vouch exec --type rds -- psql
vouch login → vouch exec --type redshift -- psql
```

---

## RDS / Aurora PostgreSQL

### Using Vouch CLI

The simplest approach is `vouch exec`, which generates the token and injects PostgreSQL environment variables (`PGPASSWORD`, `PGHOST`, `PGPORT`, `PGUSER`, `PGSSLMODE=require`) automatically:

```bash
vouch exec --type rds \
  --rds-hostname mydb.cluster-abc123.us-east-1.rds.amazonaws.com \
  --rds-username mydbuser \
  -- psql -d mydb
```

To set the variables in your current shell instead:

```bash
eval "$(vouch env --type rds \
  --rds-hostname mydb.cluster-abc123.us-east-1.rds.amazonaws.com \
  --rds-username mydbuser)"
psql -d mydb
```

To generate just the token (e.g., for scripts or non-PostgreSQL clients):

```bash
TOKEN=$(vouch credential rds \
  --hostname mydb.cluster-abc123.us-east-1.rds.amazonaws.com \
  --username mydbuser)
```

### Using AWS CLI

You can also use the AWS CLI with Vouch's `credential_process` integration:

```bash
# Generate an IAM auth token (valid for 15 minutes)
TOKEN=$(aws rds generate-db-auth-token \
  --hostname mydb.cluster-abc123.us-east-1.rds.amazonaws.com \
  --port 5432 \
  --username mydbuser \
  --profile vouch)

# Connect with psql
PGPASSWORD="$TOKEN" psql \
  -h mydb.cluster-abc123.us-east-1.rds.amazonaws.com \
  -p 5432 \
  -U mydbuser \
  -d mydb \
  "sslmode=require"
```

**Database setup:** The database user must be configured for IAM authentication. For PostgreSQL, grant the `rds_iam` role:

```sql
GRANT rds_iam TO mydbuser;
```

---

## RDS / Aurora MySQL

MySQL requires the `--enable-cleartext-plugin` flag because the IAM token is sent as a cleartext password over TLS.

### Using Vouch CLI

Generate the token with `vouch credential rds` and pass it to the MySQL client:

```bash
TOKEN=$(vouch credential rds \
  --hostname mydb.cluster-abc123.us-east-1.rds.amazonaws.com \
  --username mydbuser \
  --port 3306)

mysql -h mydb.cluster-abc123.us-east-1.rds.amazonaws.com \
  -P 3306 \
  -u mydbuser \
  --password="$TOKEN" \
  --ssl-mode=REQUIRED \
  --enable-cleartext-plugin
```

> **Note:** `vouch exec --type rds` and `vouch env --type rds` inject PostgreSQL-style environment variables (`PGPASSWORD`, `PGHOST`, etc.), so MySQL users should use `vouch credential rds` to get the token and pass it manually.

### Using AWS CLI

```bash
# Generate an IAM auth token
TOKEN=$(aws rds generate-db-auth-token \
  --hostname mydb.cluster-abc123.us-east-1.rds.amazonaws.com \
  --port 3306 \
  --username mydbuser \
  --profile vouch)

# Connect with mysql (note: --enable-cleartext-plugin is required)
mysql -h mydb.cluster-abc123.us-east-1.rds.amazonaws.com \
  -P 3306 \
  -u mydbuser \
  --password="$TOKEN" \
  --ssl-mode=REQUIRED \
  --enable-cleartext-plugin
```

**Database setup:** Create the user with the `AWSAuthenticationPlugin`:

```sql
CREATE USER 'mydbuser'@'%' IDENTIFIED WITH AWSAuthenticationPlugin AS 'RDS';
```

---

## Amazon Redshift

Redshift generates temporary database credentials with a configurable lifetime (15--60 minutes). Vouch supports both provisioned clusters and Redshift Serverless workgroups.

### Using Vouch CLI (provisioned cluster)

The simplest approach is `vouch exec`, which generates credentials and injects PostgreSQL environment variables (`PGPASSWORD`, `PGUSER`, `PGSSLMODE=require`) automatically:

```bash
vouch exec --type redshift \
  --redshift-cluster-id my-cluster \
  --redshift-db-name mydb \
  -- psql -h my-cluster.abc123.us-east-1.redshift.amazonaws.com -p 5439
```

To set the variables in your current shell:

```bash
eval "$(vouch env --type redshift \
  --redshift-cluster-id my-cluster \
  --redshift-db-name mydb)"
psql -h my-cluster.abc123.us-east-1.redshift.amazonaws.com -p 5439
```

To generate just the credentials:

```bash
vouch credential redshift --cluster-id my-cluster --db-name mydb
```

The `--duration` flag controls credential lifetime for provisioned clusters (900--3600 seconds, default: 900):

```bash
vouch credential redshift --cluster-id my-cluster --duration 3600
```

### Using Vouch CLI (Redshift Serverless)

```bash
vouch exec --type redshift \
  --redshift-workgroup my-workgroup \
  --redshift-db-name mydb \
  -- psql -h my-workgroup.123456789012.us-east-1.redshift-serverless.amazonaws.com -p 5439
```

Or generate credentials directly:

```bash
vouch credential redshift --workgroup my-workgroup --db-name mydb
```

### Using AWS CLI

```bash
# Get temporary Redshift credentials
CREDS=$(aws redshift get-cluster-credentials \
  --cluster-identifier my-cluster \
  --db-user mydbuser \
  --db-name mydb \
  --duration-seconds 3600 \
  --profile vouch)

# Extract and connect
DB_USER=$(echo "$CREDS" | jq -r '.DbUser')
DB_PASS=$(echo "$CREDS" | jq -r '.DbPassword')

PGPASSWORD="$DB_PASS" psql \
  -h my-cluster.abc123.us-east-1.redshift.amazonaws.com \
  -p 5439 \
  -U "$DB_USER" \
  -d mydb
```

---

## Required IAM permissions

Your Vouch IAM role needs permission to generate database auth tokens and credentials.

**RDS / Aurora:**

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "rds-db:connect",
      "Resource": "arn:aws:rds-db:us-east-1:123456789012:dbuser:cluster-ABC123/mydbuser"
    }
  ]
}
```

**Redshift (provisioned clusters):**

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "redshift:GetClusterCredentialsWithIAM",
      "Resource": "arn:aws:redshift:us-east-1:123456789012:dbname:my-cluster/*"
    }
  ]
}
```

**Redshift Serverless:**

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "redshift-serverless:GetCredentials",
      "Resource": "arn:aws:redshift-serverless:us-east-1:123456789012:workgroup/*"
    }
  ]
}
```

---

## Troubleshooting

### "PAM authentication failed for user"

Ensure IAM database authentication is enabled on the RDS instance and the database user has the `rds_iam` role (PostgreSQL) or was created with `AWSAuthenticationPlugin` (MySQL).

### Token expired

RDS/Aurora auth tokens are valid for 15 minutes. Generate a fresh token before connecting. The token is only used to establish the connection -- active sessions are not affected by expiry.

### SSL required error

IAM database authentication requires SSL/TLS. Use `sslmode=require` for PostgreSQL or `--ssl-mode=REQUIRED` for MySQL.



---

# Use Terraform and CDK with Hardware-Verified Credentials

Source: https://vouch.sh/docs/iac/


IaC tools like Terraform, CDK, and SAM need AWS credentials to provision infrastructure. If those credentials are long-lived access keys, a compromised dev machine could modify production infrastructure. If they're shared across the team, there's no audit trail showing who deployed what.

If a tool reads `~/.aws/config`, it already works with Vouch. The `credential_process` setting in your Vouch AWS profile is picked up by the AWS SDK, which means every IaC tool that uses the SDK gets hardware-verified credentials automatically. No plugins or wrappers needed.

## AWS CDK

```bash
cdk deploy --profile vouch
```

CDK has known issues with SSO credential discovery ([#23520](https://github.com/aws/aws-cdk/issues/23520), [#21328](https://github.com/aws/aws-cdk/issues/21328)) that `credential_process` avoids entirely.

---

## AWS SAM

```bash
sam deploy --profile vouch
```

---

## Terraform

```bash
# Set the AWS profile for the session
export AWS_PROFILE=vouch
terraform plan
terraform apply
```

This works for the AWS provider's authentication. Terraform Cloud registry auth is separate and not handled by Vouch.

---

## AWS Copilot

```bash
export AWS_PROFILE=vouch
copilot deploy
```

---

## AWS Amplify

```bash
export AWS_PROFILE=vouch
amplify push
```

With Vouch, you can skip `amplify configure` entirely -- there is no need to generate long-lived IAM access keys for local development. The `credential_process` in your Vouch profile provides credentials on demand.

---

## Pulumi

```bash
export AWS_PROFILE=vouch
pulumi up
```

---

## Tips

### Setting `AWS_PROFILE` vs `--profile`

Some tools accept `--profile vouch` as a flag, while others only read the `AWS_PROFILE` environment variable. Setting the environment variable works universally:

```bash
export AWS_PROFILE=vouch
```

Add this to your shell profile (`.bashrc`, `.zshrc`) to make it the default for all sessions.

### Multiple accounts

If you deploy to multiple AWS accounts, set up separate Vouch profiles for each:

```bash
vouch setup aws --role arn:aws:iam::111111111111:role/VouchDeveloper --profile vouch-dev
vouch setup aws --role arn:aws:iam::222222222222:role/VouchDeveloper --profile vouch-prod
```

Then specify the profile per command:

```bash
cdk deploy --profile vouch-dev
cdk deploy --profile vouch-prod
```



---

# Add Human Approval Gates to CI/CD Pipelines

Source: https://vouch.sh/docs/cicd/


Most CI/CD pipelines use service account credentials or workflow-generated OIDC tokens to deploy. Neither proves that a specific person authorized the deployment. If a workflow runs automatically on merge, any merged PR can reach production with no human checkpoint.

Vouch's OIDC attests *human presence* -- "a verified human authorized this action with their YubiKey." This enables a pattern where production deployments require an explicit YubiKey tap from an authorized deployer, with the deployer's identity embedded in the resulting AWS credentials via STS session tags.

## How it works

1. A deployer authenticates with Vouch on their local machine (`vouch login`).
2. The deployer generates a short-lived JWT (`vouch credential aws --role <ROLE_ARN>`).
3. The JWT is passed to the CI/CD pipeline (as a workflow input, secret, or environment variable).
4. The pipeline exchanges the JWT for AWS credentials using `AssumeRoleWithWebIdentity`.
5. The deployment proceeds with credentials tied to the deployer's hardware-verified identity.

---

## Step 1 -- Register Vouch as an IAM OIDC Provider

If you have not already, create the OIDC provider in your AWS account. See the [AWS setup guide](/docs/aws/) for full details.

---

## Step 2 -- Create a Deployment Role

Create an IAM role that trusts Vouch tokens and restricts access to authorized deployers:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Federated": "arn:aws:iam::ACCOUNT_ID:oidc-provider/{{< instance-url >}}"
      },
      "Action": ["sts:AssumeRoleWithWebIdentity", "sts:TagSession"],
      "Condition": {
        "StringEquals": {
          "{{< instance-url >}}:aud": "{{< instance-url >}}",
          "{{< instance-url >}}:sub": [
            "deployer@example.com",
            "release-lead@example.com"
          ]
        }
      }
    }
  ]
}
```

The `sub` condition restricts which Vouch users can assume this role.

---

## Step 3 -- GitHub Actions Workflow

In this pattern, a deployer authenticates with Vouch on their local machine, and the resulting JWT is passed to the GitHub Actions workflow as an input, which exchanges it for AWS credentials.

```yaml
name: Deploy to Production
on:
  workflow_dispatch:
    inputs:
      vouch_token:
        description: 'Vouch JWT (from: vouch credential aws --role <ROLE_ARN>)'
        required: true
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Exchange Vouch JWT for AWS credentials
        run: |
          CREDS=$(aws sts assume-role-with-web-identity \
            --role-arn arn:aws:iam::ACCOUNT_ID:role/ProductionDeployRole \
            --role-session-name "deploy-${{ github.run_id }}" \
            --web-identity-token "${{ inputs.vouch_token }}" \
            --output json)

          echo "AWS_ACCESS_KEY_ID=$(echo $CREDS | jq -r '.Credentials.AccessKeyId')" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(echo $CREDS | jq -r '.Credentials.SecretAccessKey')" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$(echo $CREDS | jq -r '.Credentials.SessionToken')" >> $GITHUB_ENV

      - name: Deploy
        run: cdk deploy --require-approval never
```

---

## Audit trail

When Vouch tokens are exchanged for STS credentials, the deployer's `email` and `domain` are embedded as STS session tags. These appear in CloudTrail under `userIdentity.sessionContext.webIdFederationData`, providing a clear chain from YubiKey tap to deployment action:

```json
{
  "userIdentity": {
    "type": "AssumedRole",
    "principalId": "AROA...:deploy-12345",
    "sessionContext": {
      "webIdFederationData": {
        "federatedProvider": "arn:aws:iam::ACCOUNT:oidc-provider/{{< instance-url >}}",
        "attributes": {
          "email": "deployer@example.com",
          "domain": "example.com"
        }
      }
    }
  }
}
```

---

## Troubleshooting

### Token expired in pipeline

Vouch JWTs have a limited lifetime. The deployer must generate the token shortly before triggering the workflow. If the token expires during deployment, the deployer needs to re-authenticate and re-trigger.

### Access denied on AssumeRoleWithWebIdentity

Check that the trust policy's `sub` condition includes the deployer's email and the `aud` matches {{< instance-url >}}.



---

# Access Amazon Bedrock with Hardware-Verified Credentials

Source: https://vouch.sh/docs/bedrock/


AI model access creates unique audit and cost challenges. Shared API keys make it impossible to attribute usage to individual developers, and a leaked key means unlimited access to expensive model invocations with no way to trace who's responsible.

[Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html) uses standard AWS SigV4 authentication. Vouch's `credential_process` provides STS credentials backed by FIDO2 verification, which means every Amazon Bedrock API call is tied to a hardware-verified human identity.

```
YubiKey tap → FIDO2 → Vouch JWT → STS → Amazon Bedrock InvokeModel → CloudTrail
```

## Why this matters

- **Every API call has a verified identity** -- no shared API keys or service accounts for human users.
- **CloudTrail captures the full chain** -- from YubiKey tap to model invocation.
- **Cost attribution per user** -- with [Amazon Bedrock model invocation logging](https://docs.aws.amazon.com/bedrock/latest/userguide/model-invocation-logging.html) enabled, token counts and costs are tied to hardware-verified identities.

---

## Step 1 -- Use Amazon Bedrock with Vouch

Any tool that uses the AWS SDK for Amazon Bedrock will pick up Vouch credentials automatically:

```bash
# AWS CLI
aws bedrock-runtime invoke-model \
  --model-id anthropic.claude-sonnet-4-20250514 \
  --body '{"prompt": "Hello"}' \
  --profile vouch \
  output.json
```

```python
# Python (boto3)
import boto3

session = boto3.Session(profile_name='vouch')
bedrock = session.client('bedrock-runtime')
response = bedrock.invoke_model(
    modelId='anthropic.claude-sonnet-4-20250514',
    body='{"prompt": "Hello"}'
)
```

---

## Step 2 -- Restrict model access by IAM policy

Use IAM policies to control which foundation models each role can invoke:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "bedrock:InvokeModel",
        "bedrock:InvokeModelWithResponseStream"
      ],
      "Resource": [
        "arn:aws:bedrock:us-east-1::foundation-model/anthropic.claude-sonnet-4-20250514",
        "arn:aws:bedrock:us-east-1::foundation-model/anthropic.claude-haiku-4-20250514"
      ]
    }
  ]
}
```

Restricting to specific model ARNs prevents users from accessing more expensive or higher-capability models without authorization.

---

## The audit chain

CloudTrail records every Amazon Bedrock API call with the full identity chain. The `webIdFederationData` field includes the Vouch OIDC issuer and the user's email (from the `sub` claim).

With [Amazon Bedrock model invocation logging](https://docs.aws.amazon.com/bedrock/latest/userguide/model-invocation-logging.html) enabled, you get token counts and costs attributed to hardware-verified identities.

---

## Agent delegation

For automated agents that call Amazon Bedrock on behalf of users, you can use scoped JWTs with agent-specific `sub` claims and session policies that limit model access. This preserves the human identity chain while restricting the agent's capabilities to only the models it needs.



---

# Vouch CLI Reference

Source: https://vouch.sh/docs/cli-reference/


This page documents all available Vouch CLI commands. For installation instructions, see [Getting Started](/docs/getting-started/).

---

## Global flags

These flags are available on all commands.

| Flag | Description |
|---|---|
| `--server <URL>` | Vouch server URL (also settable via `VOUCH_SERVER` environment variable). Saved locally after enrollment. |
| `-v`, `--verbose` | Enable debug logging |
| `--color <MODE>` | Control color output: `auto` (default), `always`, or `never` |

---

## Authentication

### `vouch enroll`

Register your YubiKey with a Vouch server and link it to your identity.

```
vouch enroll --server <SERVER_URL>
```

You only need to enroll once per YubiKey.

### `vouch login`

Authenticate with your YubiKey and start an 8-hour session.

```
vouch login [--timeout <SECONDS>]
```

| Flag | Description |
|---|---|
| `--timeout` | Timeout in seconds for YubiKey detection (default: `60`, use `0` for no timeout) |

After login, all credential helpers use the session automatically. Run this once at the start of each workday.

### `vouch logout`

End the current session and clear all cached credentials.

```
vouch logout
```

### `vouch status`

Display the current session status, including remaining session time and active integrations (SSH, AWS, SSM, Git, Docker, Cargo).

```
vouch status [--format <FORMAT>]
```

| Flag | Description |
|---|---|
| `--format` | Output format: `human` (default), `json`, or `shell`. The `shell` format outputs key=value pairs suitable for `eval`. |

---

## Setup

Setup commands configure credential helpers for each integration. Run these once per machine.

### `vouch setup aws`

Configure the AWS credential process for an IAM role.

```
vouch setup aws --role <ROLE_ARN> [--profile <PROFILE>]
```

| Flag | Description |
|---|---|
| `--role` | The IAM role ARN to assume (required) |
| `--profile` | AWS profile name to configure (default: `vouch`; additional profiles auto-name as `vouch-2`, `vouch-3`, etc.) |

See [AWS Integration](/docs/aws/) for full details.

### `vouch setup ssh`

Configure the SSH client to use the Vouch agent for certificate authentication.

```
vouch setup ssh [--hosts <PATTERN>]
```

| Flag | Description |
|---|---|
| `--hosts` | Host patterns to trust with this CA (e.g., `*.example.com`). If specified, adds an entry to `~/.ssh/known_hosts`. |

See [SSH Certificates](/docs/ssh/) for full details.

### `vouch setup github`

Configure Git to use Vouch as the credential helper for GitHub.

```
vouch setup github [--host <HOST>] [--configure]
```

| Flag | Description |
|---|---|
| `--host` | GitHub host to configure (default: `github.com`) |
| `--configure` | Apply the configuration automatically (without this flag, the command only prints the configuration) |

See [GitHub Integration](/docs/github/) for full details.

### `vouch setup docker`

Configure Docker to use Vouch as the credential helper for container registries.

```
vouch setup docker [--configure] [REGISTRIES...]
```

| Flag | Description |
|---|---|
| `--configure` | Apply the configuration automatically (without this flag, the command only prints the configuration) |
| `REGISTRIES` | Container registry URLs to configure (e.g., `ghcr.io`) |

See [Docker Registries](/docs/docker/) for full details.

### `vouch setup cargo`

Configure Cargo to use Vouch as the credential provider for private registries.

```
vouch setup cargo [--registry <NAME>] [--configure]
```

| Flag | Description |
|---|---|
| `--registry` | Name of the Cargo registry to configure |
| `--configure` | Apply the configuration automatically |

See [Cargo Integration](/docs/cargo/) for full details.

### `vouch setup codeartifact`

Configure a package manager for an AWS CodeArtifact repository.

```
vouch setup codeartifact --tool <TOOL> --repository <REPO> [--domain <DOMAIN>] [--domain-owner <ACCOUNT_ID>] [--region <REGION>] [--profile <PROFILE>]
```

| Flag | Description |
|---|---|
| `--tool` | Package manager to configure: `cargo`, `pip`, or `npm` (required) |
| `--repository` | The AWS CodeArtifact repository name (required) |
| `--domain` | The AWS CodeArtifact domain name (optional if a profile is configured) |
| `--domain-owner` | AWS account ID that owns the domain (optional if a profile is configured) |
| `--region` | AWS region (optional if a profile is configured) |
| `--profile` | Named AWS CodeArtifact profile to use or create (stores domain/owner/region for reuse) |

See [AWS CodeArtifact](/docs/codeartifact/) for full details.

### `vouch setup codecommit`

Configure Git to use Vouch as the credential helper for AWS CodeCommit.

```
vouch setup codecommit [--region <REGION>] [--profile <PROFILE>] [--configure]
```

| Flag | Description |
|---|---|
| `--region` | AWS region (default: wildcard matching all regions) |
| `--profile` | AWS profile to use (defaults to auto-detected vouch profile) |
| `--configure` | Apply the configuration automatically (without this flag, the command only prints the configuration) |

See [AWS CodeCommit](/docs/codecommit/) for full details.

### `vouch setup eks`

Configure kubectl to use Vouch for EKS cluster authentication.

```
vouch setup eks --cluster <CLUSTER_NAME> [--region <REGION>] [--profile <PROFILE>] [--kubeconfig <PATH>]
```

| Flag | Description |
|---|---|
| `--cluster` | The EKS cluster name (required) |
| `--region` | AWS region (auto-detected from AWS profile or environment if not specified) |
| `--profile` | AWS profile to use (defaults to auto-detected vouch profile) |
| `--kubeconfig` | Path to kubeconfig file (defaults to `~/.kube/config`) |

See [Amazon EKS](/docs/eks/) for full details.

### `vouch setup ssm`

Configure SSH to use AWS Systems Manager Session Manager as a proxy for connections to EC2 and managed instances.

```
vouch setup ssm [--profile <PROFILE>] [--region <REGION>] [--hosts <HOSTS>] [--force]
```

| Flag | Description |
|---|---|
| `--profile` | AWS profile to use (defaults to auto-detected vouch profile) |
| `--region` | AWS region to use in the ProxyCommand |
| `--hosts` | Host patterns to match (default: `i-* mi-*`) |
| `--force` | Overwrite any existing SSM configuration in `~/.ssh/config` |

See [AWS Systems Manager](/docs/ssm/) for full details.

---

## Credentials

Credential commands obtain service-specific credentials from your active session. These are typically called automatically by credential helpers, but can be run manually for debugging.

### `vouch credential aws`

Obtain temporary AWS STS credentials.

```
vouch credential aws --role <ROLE_ARN> [--session-name <NAME>]
```

| Flag | Description |
|---|---|
| `--role` | The IAM role ARN to assume (required) |
| `--session-name` | Session name for the assumed role |

### `vouch credential ssh`

Obtain an SSH certificate from the Vouch server.

```
vouch credential ssh [--key <PATH>]
```

| Flag | Description |
|---|---|
| `--key` | Path to SSH private key (default: `~/.ssh/id_ed25519_vouch`) |

### `vouch credential github`

Git credential helper for GitHub. This command is invoked automatically by Git when configured via `vouch setup github`. Users should not call it directly.

### `vouch credential docker`

Docker credential helper for container registries. This command is invoked automatically by Docker when configured via `vouch setup docker`. Users should not call it directly.

### `vouch credential cargo`

Cargo credential provider for private registries. This command is invoked automatically by Cargo when configured via `vouch setup cargo`. Users should not call it directly.

### `vouch credential codeartifact`

Obtain an AWS CodeArtifact authorization token.

```
vouch credential codeartifact [--domain <DOMAIN>] [--domain-owner <ACCOUNT_ID>] [--region <REGION>] [--profile <PROFILE>]
```

| Flag | Description |
|---|---|
| `--domain` | The AWS CodeArtifact domain name (optional if a profile is configured) |
| `--domain-owner` | AWS account ID that owns the domain (optional if a profile is configured) |
| `--region` | AWS region (optional if a profile is configured) |
| `--profile` | Named AWS CodeArtifact profile to use |

### `vouch credential codecommit`

Git credential helper for AWS CodeCommit. This command is invoked automatically by Git when configured via `vouch setup codecommit`. Users should not call it directly.

### `vouch credential pip`

Credential helper for pip/PyPI. This command is invoked automatically by pip when configured via `vouch setup codeartifact --tool pip`. Users should not call it directly.

### `vouch credential rds`

Generate an RDS IAM authentication token for database connections. The token is valid for 15 minutes.

```
vouch credential rds --hostname <HOSTNAME> --username <USERNAME> [--port <PORT>] [--region <REGION>] [--role <ROLE>]
```

| Flag | Description |
|---|---|
| `--hostname` | RDS instance hostname (required) |
| `--username` | Database username (required) |
| `--port` | Database port (default: `5432`) |
| `--region` | AWS region (auto-detected if not specified) |
| `--role` | AWS IAM role ARN (auto-detected from vouch profile if not specified) |

Example:

```bash
TOKEN=$(vouch credential rds \
  --hostname mydb.cluster-abc123.us-east-1.rds.amazonaws.com \
  --username mydbuser)

PGPASSWORD="$TOKEN" psql -h mydb.cluster-abc123.us-east-1.rds.amazonaws.com -U mydbuser -d mydb "sslmode=require"
```

### `vouch credential redshift`

Generate temporary credentials for Amazon Redshift. Supports both provisioned clusters and Redshift Serverless workgroups.

```
vouch credential redshift (--cluster-id <ID> | --workgroup <NAME>) [--db-name <NAME>] [--region <REGION>] [--role <ROLE>] [--duration <SECONDS>]
```

| Flag | Description |
|---|---|
| `--cluster-id` | Redshift provisioned cluster identifier (mutually exclusive with `--workgroup`) |
| `--workgroup` | Redshift Serverless workgroup name (mutually exclusive with `--cluster-id`) |
| `--db-name` | Database name (optional) |
| `--region` | AWS region (auto-detected if not specified) |
| `--role` | AWS IAM role ARN (auto-detected from vouch profile if not specified) |
| `--duration` | Credential duration in seconds, 900--3600 (provisioned clusters only, default: `900`) |

Examples:

```bash
# Provisioned cluster
vouch credential redshift --cluster-id my-cluster --db-name mydb

# Serverless workgroup
vouch credential redshift --workgroup my-workgroup --db-name mydb
```

### `vouch credential token`

Print the raw session access token to stdout for use with curl or other tools.

```
vouch credential token
```

Example:

```bash
curl -H "Authorization: Bearer $(vouch credential token)" https://api.example.com/endpoint
```

---

## Key management

### `vouch register`

Register an additional YubiKey with your account.

```
vouch register [--name <NAME>] [--timeout <SECONDS>]
```

| Flag | Description |
|---|---|
| `--name` | Human-readable name for this YubiKey (default: `YubiKey`) |
| `--timeout` | Timeout in seconds for YubiKey detection (default: `60`, use `0` for no timeout) |

This allows you to use multiple hardware keys (e.g., a primary and a backup) with the same Vouch identity.

### `vouch keys list`

List all registered security keys for your account.

```
vouch keys list [--json]
```

| Flag | Description |
|---|---|
| `--json` | Output as JSON |

### `vouch keys remove`

Remove a registered security key from your account.

```
vouch keys remove <KEY_ID> [--force]
```

| Flag | Description |
|---|---|
| `-f`, `--force` | Skip the confirmation prompt |

### `vouch keys rename`

Rename a registered security key.

```
vouch keys rename <KEY_ID> <NEW_NAME>
```

---

## Environment

### `vouch exec`

Run a command with Vouch credentials injected as environment variables.

```
vouch exec --type <TYPE> [FLAGS...] -- <COMMAND> [ARGS...]
```

| Flag | Description |
|---|---|
| `--type` | Credential type to inject: `aws`, `github`, `codeartifact`, `rds`, or `redshift` (required) |
| `--role` | AWS IAM role ARN (required when `--type aws`) |
| `--session-name` | Session name for the assumed role (when `--type aws`) |
| `--ca-domain` | AWS CodeArtifact domain name (when `--type codeartifact`; optional if a profile is configured) |
| `--ca-domain-owner` | AWS account ID that owns the domain (when `--type codeartifact`; optional if a profile is configured) |
| `--ca-region` | AWS region (when `--type codeartifact`; optional if a profile is configured) |
| `--ca-profile` | Named AWS CodeArtifact profile to use (when `--type codeartifact`) |
| `--rds-hostname` | RDS instance hostname (required when `--type rds`) |
| `--rds-username` | Database username (required when `--type rds`) |
| `--rds-port` | Database port (when `--type rds`, default: `5432`) |
| `--redshift-cluster-id` | Redshift provisioned cluster identifier (when `--type redshift`; mutually exclusive with `--redshift-workgroup`) |
| `--redshift-workgroup` | Redshift Serverless workgroup name (when `--type redshift`; mutually exclusive with `--redshift-cluster-id`) |
| `--redshift-db-name` | Database name (when `--type redshift`) |
| `--redshift-duration` | Credential duration in seconds, 900--3600 (when `--type redshift`, provisioned clusters only, default: `900`) |

Environment variables injected by type:

| Type | Variables |
|---|---|
| `aws` | `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_SESSION_TOKEN` |
| `github` | `GITHUB_TOKEN` |
| `codeartifact` | `CODEARTIFACT_AUTH_TOKEN` |
| `rds` | `PGPASSWORD`, `PGHOST`, `PGPORT`, `PGUSER`, `PGSSLMODE` |
| `redshift` | `PGPASSWORD`, `PGUSER`, `PGSSLMODE` |

Examples:

```bash
# AWS credentials
vouch exec --type aws --role arn:aws:iam::123456789012:role/VouchDeveloper -- terraform plan

# AWS CodeArtifact token
vouch exec --type codeartifact -- mvn deploy -s settings.xml

# RDS PostgreSQL — connect with psql, no manual token handling
vouch exec --type rds \
  --rds-hostname mydb.cluster-abc123.us-east-1.rds.amazonaws.com \
  --rds-username mydbuser \
  -- psql -d mydb

# Redshift provisioned cluster
vouch exec --type redshift \
  --redshift-cluster-id my-cluster \
  --redshift-db-name mydb \
  -- psql -h my-cluster.abc123.us-east-1.redshift.amazonaws.com -p 5439

# Redshift Serverless
vouch exec --type redshift \
  --redshift-workgroup my-workgroup \
  -- psql -h my-workgroup.123456789012.us-east-1.redshift-serverless.amazonaws.com -p 5439
```

### `vouch env`

Output credential environment variables for use with `eval`. This sets variables like `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, and `AWS_SESSION_TOKEN` (for AWS), `GITHUB_TOKEN` (for GitHub), or `CODEARTIFACT_AUTH_TOKEN` (for AWS CodeArtifact) in your current shell.

```
eval "$(vouch env --type <TYPE> [--shell <SHELL>] [FLAGS...])"
```

| Flag | Description |
|---|---|
| `--type` | Credential type: `aws`, `github`, `codeartifact`, `rds`, or `redshift` (required) |
| `--shell` | Shell syntax: `bash` or `fish` (default: `bash`). The `bash` syntax also works for zsh. |
| `--role` | AWS IAM role ARN (required when `--type aws`) |
| `--session-name` | Session name for the assumed role (when `--type aws`) |
| `--ca-domain` | AWS CodeArtifact domain name (when `--type codeartifact`; optional if a profile is configured) |
| `--ca-domain-owner` | AWS account ID that owns the domain (when `--type codeartifact`; optional if a profile is configured) |
| `--ca-region` | AWS region (when `--type codeartifact`; optional if a profile is configured) |
| `--ca-profile` | Named AWS CodeArtifact profile to use (when `--type codeartifact`) |
| `--rds-hostname` | RDS instance hostname (required when `--type rds`) |
| `--rds-username` | Database username (required when `--type rds`) |
| `--rds-port` | Database port (when `--type rds`, default: `5432`) |
| `--redshift-cluster-id` | Redshift provisioned cluster identifier (when `--type redshift`; mutually exclusive with `--redshift-workgroup`) |
| `--redshift-workgroup` | Redshift Serverless workgroup name (when `--type redshift`; mutually exclusive with `--redshift-cluster-id`) |
| `--redshift-db-name` | Database name (when `--type redshift`) |
| `--redshift-duration` | Credential duration in seconds, 900--3600 (when `--type redshift`, provisioned clusters only, default: `900`) |

Environment variables set by type:

| Type | Variables |
|---|---|
| `aws` | `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_SESSION_TOKEN` |
| `github` | `GITHUB_TOKEN` |
| `codeartifact` | `CODEARTIFACT_AUTH_TOKEN` |
| `rds` | `PGPASSWORD`, `PGHOST`, `PGPORT`, `PGUSER`, `PGSSLMODE` |
| `redshift` | `PGPASSWORD`, `PGUSER`, `PGSSLMODE` |

Examples:

```bash
# RDS PostgreSQL
eval "$(vouch env --type rds \
  --rds-hostname mydb.cluster-abc123.us-east-1.rds.amazonaws.com \
  --rds-username mydbuser)"
psql -d mydb

# Redshift
eval "$(vouch env --type redshift \
  --redshift-cluster-id my-cluster \
  --redshift-db-name mydb)"
psql -h my-cluster.abc123.us-east-1.redshift.amazonaws.com -p 5439
```

### `vouch init`

Output a shell hook that sets `VOUCH_AUTHENTICATED`, `VOUCH_EMAIL`, and `VOUCH_EXPIRES_IN` on each prompt. Add to your shell profile for ambient session awareness.

```
eval "$(vouch init <SHELL>)"
```

Supported shells: `bash`, `zsh`, `fish`.

---

## Diagnostics

### `vouch doctor`

Run diagnostic checks to verify your Vouch installation and configuration.

```
vouch doctor [--quiet] [--json]
```

| Flag | Description |
|---|---|
| `-q`, `--quiet` | Suppress all output (exit code only) |
| `--json` | Output results as JSON |

This checks:

- CLI version and updates
- Agent connectivity
- Server reachability
- Integration configurations (SSH, AWS, SSM, Git, Docker, Cargo)

### `vouch completions`

Generate shell completion scripts.

```
vouch completions <SHELL>
```

Supported shells: `bash`, `zsh`, `fish`, `powershell`, `elvish`.

Example:

```bash
# Add to your ~/.zshrc
eval "$(vouch completions zsh)"
```

---

## Exit codes

| Code | Meaning |
|---|---|
| `0` | Success |
| `1` | General error |
| `2` | Not authenticated (session expired or missing) |
| `3` | Hardware key not detected |
| `4` | Network or server unreachable |
| `5` | Permission denied |
| `6` | Configuration error |
| `7` | Step-up authentication required |

---

## Binary download verification

If you downloaded the Vouch CLI binary directly from the [GitHub releases](https://github.com/vouch-sh/vouch/releases) page, you can verify its integrity using the SHA256 checksums and SLSA provenance attestation published alongside each release.

### SHA256 checksum

Each release includes a `checksums.txt` file. Verify the downloaded binary:

```bash
sha256sum --check checksums.txt
```

### SLSA provenance

Vouch release binaries are built with SLSA Level 3 provenance. You can verify the provenance attestation using the [slsa-verifier](https://github.com/slsa-framework/slsa-verifier) tool:

```bash
slsa-verifier verify-artifact vouch-linux-amd64 \
  --provenance-path vouch-linux-amd64.intoto.jsonl \
  --source-uri github.com/vouch-sh/vouch
```



---

# Security Model

Source: https://vouch.sh/docs/security/


Vouch brokers the most sensitive credentials in a developer's stack: SSH certificates, AWS STS tokens, GitHub installation tokens, and container registry passwords. This page explains exactly how those credentials are protected at every layer.

---

## Data flow

Every Vouch credential follows the same path from hardware key to cloud service:

```
YubiKey (FIDO2)
  → Vouch CLI (local machine)
    → Vouch Server (validates assertion, issues session)
      → External service (AWS STS / GitHub / SSH CA)
        → Short-lived credential returned to CLI
          → Tool uses credential (aws, ssh, git, docker)
```

1. **FIDO2 assertion** -- The YubiKey signs a challenge using a private key that never leaves the hardware. The assertion includes origin binding (preventing phishing) and user verification (PIN + touch).
2. **Session issuance** -- The Vouch server validates the signed assertion against the enrolled public key and issues a session token valid for 8 hours.
3. **Credential exchange** -- When a tool needs a credential, the CLI exchanges the session token for a service-specific credential (STS `AssumeRoleWithWebIdentity`, SSH certificate signing, GitHub App installation token, etc.).
4. **Tool consumption** -- The tool receives the short-lived credential and uses it normally. The credential expires on its own -- there is nothing to revoke or rotate.

---

## Credential lifecycle

All Vouch credentials share these properties:

| Property | Detail |
|---|---|
| **Storage** | In-memory only, held by the Vouch agent process. Never written to disk. |
| **Lifetime** | Session: 8 hours. AWS STS: up to 1 hour. SSH certificate: 8 hours. GitHub token: 1 hour. |
| **Scope** | Tied to a single authenticated user. Cannot be shared or transferred. |
| **Revocation** | Sessions can be revoked server-side (e.g., via SCIM de-provisioning). Outstanding short-lived credentials expire naturally. |
| **Rotation** | Not applicable -- credentials are issued fresh on each request and expire automatically. |

Because credentials are never written to disk, they cannot be exfiltrated by malware scanning `~/.aws/credentials`, `~/.ssh/`, or environment variables.

---

## Trust boundaries

Vouch operates across three trust boundaries:

### 1. Hardware key (YubiKey)

- Private key material is generated on the YubiKey and **never exported**.
- FIDO2 assertions are origin-bound -- the key will not sign challenges from phishing domains.
- User verification requires both a PIN and a physical touch.

### 2. Local machine (CLI + Agent)

- The Vouch agent runs as a user-level process and holds session material in memory.
- Communication between the CLI and agent uses a Unix domain socket with filesystem permissions restricting access to the owning user.
- No credentials are persisted to disk. If the agent process stops, sessions must be re-established with a new `vouch login`.

### 3. Vouch server

- The server validates FIDO2 assertions and issues signed OIDC tokens (ES256 over P-256).
- The server does not store AWS credentials, SSH private keys, or GitHub tokens. It acts as an identity broker, not a secrets vault.
- Communication between CLI and server uses TLS 1.2+.

---

## Threat model

For the complete STRIDE-based threat analysis — including threat actors, trust boundaries, assumptions, structured threat statements, and mitigations — see the dedicated [Threat Model](/docs/threat-model/) page.

---

## Encryption

### In transit

All communication between the Vouch CLI and server uses **TLS 1.2+**. The FIDO2 assertion is transmitted over this encrypted channel.

### At rest

Vouch does not store credentials at rest. The server stores:

- **Enrolled public keys** -- The FIDO2 public key registered during enrollment. This is not sensitive (it cannot be used to impersonate the user).
- **User metadata** -- Email address, organization membership, and enrollment status.
- **Audit logs** -- Records of authentication events and credential issuance.

No private keys, AWS credentials, SSH keys, or tokens are stored on the server.

---

## FIDO2 security properties

Vouch uses [FIDO2/WebAuthn](https://fidoalliance.org/fido2/) for all user authentication. Key security properties:

- **Origin binding** -- The authenticator (YubiKey) includes the relying party ID in the signed assertion. If an attacker stands up a phishing site at a different domain, the assertion will not validate against the Vouch server.
- **Hardware key storage** -- The private key is generated on the YubiKey's secure element and cannot be extracted, cloned, or backed up.
- **User verification** -- Every assertion requires the user's PIN and a physical touch of the key, providing two-factor authentication in a single gesture.
- **Replay protection** -- Each assertion includes a signature counter that the server tracks. Replayed assertions are rejected.

---

## OAuth 2.0 security architecture

FIDO2 proves the human is present. The OAuth 2.0 layer protects everything after — how the CLI identifies itself, how authorization requests are transmitted, and how tokens are bound to the device that requested them. Together, these form a [FAPI 2.0 Security Profile](https://openid.net/specs/fapi-security-profile-2_0-final.html).

**No shared secrets.** The CLI generates its own key pair and registers with the server automatically ([RFC 7591](https://datatracker.ietf.org/doc/html/rfc7591)). Client authentication uses `private_key_jwt` ([RFC 7523](https://datatracker.ietf.org/doc/html/rfc7523)) — there is no client secret to extract from a binary or config file.

**Protected authorization requests.** Authorization parameters are sent directly to the server over a back-channel ([RFC 9126](https://datatracker.ietf.org/doc/html/rfc9126)) and signed as JWTs ([RFC 9101](https://datatracker.ietf.org/doc/html/rfc9101)). The browser redirect carries only an opaque reference — nothing sensitive in URLs, browser history, or referrer headers.

**Sender-constrained tokens.** Every access token is bound to the CLI's key pair via DPoP ([RFC 9449](https://datatracker.ietf.org/doc/html/rfc9449)). A stolen token cannot be used from a different machine.

**Audience-restricted tokens.** Each token includes a resource indicator ([RFC 8707](https://datatracker.ietf.org/doc/html/rfc8707)) restricting it to a specific service. A token issued for AWS cannot be presented to GitHub.

---

## Supply chain security

### SLSA provenance

Vouch release binaries are built with [SLSA Level 3](https://slsa.dev/) provenance. Each release includes a provenance attestation that you can verify:

```bash
slsa-verifier verify-artifact vouch-linux-amd64 \
  --provenance-path vouch-linux-amd64.intoto.jsonl \
  --source-uri github.com/vouch-sh/vouch
```

This confirms the binary was built from the expected source repository using a tamper-resistant build process.

### SHA256 checksums

Every release includes a `checksums.txt` file. Verify downloaded binaries:

```bash
sha256sum --check checksums.txt
```

### Package manager verification

When installed via Homebrew, APT, or DNF, package signatures are verified automatically by the package manager using Vouch's published GPG key.

---

## Shared responsibility

### Vouch's responsibilities

- Secure the server infrastructure and FIDO2 registration data.
- Issue credentials with minimum necessary lifetime and scope.
- Provide SLSA-attested builds and signed packages.
- Revoke sessions when triggered by SCIM de-provisioning.
- Maintain audit logs of all authentication and credential issuance events.

### Your responsibilities

- Protect YubiKeys and PINs. Report lost or stolen keys immediately.
- Configure IAM roles with least-privilege permissions.
- Set up SCIM to automate user lifecycle management.
- Monitor CloudTrail and server audit logs for anomalous activity.
- Keep the Vouch CLI updated to receive security patches.

---

## Compliance

Vouch's FAPI 2.0 security profile and hardware-backed authentication satisfy requirements across multiple compliance frameworks:

- **NIST 800-53** — IA-2 (identification/authentication), IA-5 (authenticator management), SC-23 (session authenticity)
- **SOC 2** — CC6.1 (logical access), CC6.8 (unauthorized access prevention), CC7.1 (detection)
- **FedRAMP** — Hardware MFA, DPoP sender-constrained tokens, non-extractable keys
- **HIPAA** — 164.312(d) (person authentication), 164.312(e) (transmission security)

Detailed control-by-control mappings are available in the [Vouch server documentation](https://docs.vouch.sh/reference/compliance.html).

---

## Incident response

If you suspect a security issue with the Vouch service or have discovered a vulnerability:

- Email **security@vouch.sh** with details.
- Include reproduction steps if possible.
- Do not disclose the issue publicly until it has been addressed.

If a YubiKey is lost or stolen, remove it from the user's account immediately to prevent unauthorized authentication.



---

# Threat Model

Source: https://vouch.sh/docs/threat-model/


This threat model documents the threats Vouch is designed to address, the assumptions the design relies on, and the mitigations in place. It follows the [STRIDE](https://en.wikipedia.org/wiki/STRIDE_(security)) framework and is structured after the [AWS Threat Composer](https://awslabs.github.io/threat-composer/) methodology.

For background on Vouch's security controls, see the [Security Model](/docs/security/) page. For system design details, see the [Architecture Overview](/docs/architecture/) page.

---

## System description

Vouch is a credential broker that replaces long-lived developer secrets (AWS access keys, SSH private keys, GitHub PATs) with short-lived, hardware-backed credentials. The system has three components:

- **Vouch CLI + Agent** — runs on the developer's machine, holds session state in memory, and serves credentials to tools via standard protocols (credential helper, SSH agent).
- **Vouch Server** — validates FIDO2 assertions, issues OIDC tokens, signs SSH certificates, and brokers credentials from external services.
- **External services** — AWS STS, GitHub Apps, SSH hosts, container registries, and other services that consume Vouch-issued credentials.

---

## Threat actors

| Actor | Description | Capability |
|---|---|---|
| **External attacker** | An adversary with no prior access to the organization's systems. Operates over the network. | Phishing, credential stuffing, man-in-the-middle attacks, domain spoofing, supply chain attacks on public packages. |
| **Malicious insider** | An authenticated employee or contractor who abuses legitimate access. | Valid Vouch session, access to internal systems, knowledge of organizational structure and tooling. |
| **Compromised endpoint** | Malware or an attacker with code execution on a developer's workstation. | Can read process memory, intercept IPC, access filesystem, and make network requests as the local user. |
| **Compromised server** | An attacker who has gained access to the Vouch server infrastructure. | Can issue sessions, sign tokens, and read enrolled public keys and audit logs. |
| **Supply chain attacker** | An adversary who tampers with Vouch binaries, dependencies, or distribution channels. | Can inject malicious code into CLI binaries or modify package repositories. |

---

## Trust boundaries

```
┌─────────────────────────────────────────────────────────────────────┐
│  Developer Workstation                                              │
│                                                                     │
│  ┌───────────┐    Unix socket    ┌────────────┐                     │
│  │ Vouch CLI │◄─────────────────►│ Vouch Agent│                     │
│  └─────┬─────┘  (owner-only)     └─────┬──────┘                     │
│        │                               │                            │
│  ┌─────┴─────┐                   ┌─────┴──────┐                     │
│  │  YubiKey  │                   │ In-memory   │                     │
│  │  (FIDO2)  │                   │ credentials │                     │
│  └───────────┘                   └────────────┘                     │
│                                                                     │
└──────────────────────────┬──────────────────────────────────────────┘
                           │ TLS 1.2+
              ─────────────┼──────────── Network boundary
                           │
┌──────────────────────────┴──────────────────────────────────────────┐
│  Vouch Server                                                       │
│                                                                     │
│  ┌──────────────┐  ┌──────────────┐  ┌────────────────────┐        │
│  │ FIDO2 RP     │  │ OIDC Provider│  │ SSH CA (Ed25519)   │        │
│  │ (assertion   │  │ (ES256 JWT   │  │ (certificate       │        │
│  │  validation) │  │  issuance)   │  │  signing)          │        │
│  └──────────────┘  └──────────────┘  └────────────────────┘        │
│                                                                     │
│  ┌──────────────┐  ┌──────────────┐                                 │
│  │ User store   │  │ Audit log    │                                 │
│  │ (public keys,│  │ (auth events,│                                 │
│  │  metadata)   │  │  issuance)   │                                 │
│  └──────────────┘  └──────────────┘                                 │
│                                                                     │
└──────────────────────────┬──────────────────────────────────────────┘
                           │ TLS 1.2+
              ─────────────┼──────────── Service boundary
                           │
┌──────────────────────────┴──────────────────────────────────────────┐
│  External Services                                                  │
│                                                                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌────────────────┐      │
│  │ AWS STS  │  │ GitHub   │  │ SSH Hosts│  │ Container      │      │
│  │          │  │ Apps API │  │          │  │ Registries     │      │
│  └──────────┘  └──────────┘  └──────────┘  └────────────────┘      │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

Three trust boundaries separate the system:

1. **Hardware boundary** — The YubiKey's secure element. Private keys are generated on-device and cannot be extracted.
2. **Workstation boundary** — The developer's machine. The agent process, Unix socket, and in-memory credentials are protected by OS-level user isolation.
3. **Network boundary** — All communication between CLI and server, and between server and external services, uses TLS 1.2+.

---

## Assumptions

These assumptions underpin the threat model. If an assumption is violated, the corresponding threats may not be adequately mitigated.

| ID | Assumption | Linked threats |
|---|---|---|
| **A1** | The YubiKey secure element correctly implements FIDO2 and does not leak private key material. | T-S1, T-S2 |
| **A2** | The operating system enforces Unix socket file permissions, preventing other users from accessing the agent socket. | T-I1, T-E1 |
| **A3** | TLS 1.2+ is not broken — an attacker cannot decrypt or tamper with data in transit. | T-T1, T-I2 |
| **A4** | AWS STS, GitHub, and other external services correctly validate OIDC tokens and enforce their own access controls. | T-E2 |
| **A5** | The developer's workstation has not been fully compromised at the kernel level (no rootkit). User-space isolation is intact. | T-I1, T-E1 |
| **A6** | SCIM de-provisioning events are delivered promptly by the identity provider. | T-S3 |
| **A7** | The Vouch server infrastructure is hardened and access-controlled (encrypted at rest, network isolation, audited access). | T-T2, T-E3 |
| **A8** | Developers keep their YubiKey PINs secret and report lost or stolen keys promptly. | T-S2 |

---

## Threats

Threats are organized using the [STRIDE](https://en.wikipedia.org/wiki/STRIDE_(security)) categories. Each threat follows the structured grammar: **a [threat actor] with [prerequisites] can [action], leading to [impact]**.

### Spoofing

<div class="threat-table">

| ID | Threat | STRIDE | Severity |
|---|---|---|---|
| **T-S1** | An **external attacker** who controls a lookalike domain can **stand up a phishing site** to capture developer credentials, leading to **unauthorized access** to the developer's accounts. | Spoofing | High |
| **T-S2** | An **external attacker** with physical access to a stolen YubiKey and knowledge of the PIN can **authenticate as the enrolled user**, leading to **unauthorized credential issuance** for the session lifetime. | Spoofing | High |
| **T-S3** | A **former employee** whose SCIM de-provisioning is delayed can **continue to use an active session**, leading to **unauthorized access** to organizational resources after offboarding. | Spoofing | Medium |

</div>

**Mitigations:**

- **T-S1**: FIDO2 origin binding prevents the YubiKey from signing assertions for unregistered domains. Even if a developer visits a phishing site, the authenticator will not produce a valid assertion. → [FIDO2 security properties](/docs/security/#fido2-security-properties)
- **T-S2**: YubiKey PINs provide a second factor — physical possession alone is insufficient. Keys should be reported lost immediately, and the enrolled credential should be removed from the user's account. Session lifetime (8 hours) limits the window.
- **T-S3**: SCIM integration enables automated de-provisioning. Sessions can also be revoked server-side. Outstanding short-lived credentials (≤1 hour) expire naturally.

---

### Tampering

<div class="threat-table">

| ID | Threat | STRIDE | Severity |
|---|---|---|---|
| **T-T1** | An **external attacker** in a network position (e.g., compromised Wi-Fi) can **intercept and modify requests** between the CLI and server, leading to **session hijacking or credential injection**. | Tampering | High |
| **T-T2** | A **compromised server** operator can **modify the OIDC signing keys or SSH CA key**, leading to **issuance of fraudulent credentials** accepted by external services. | Tampering | Critical |
| **T-T3** | A **supply chain attacker** can **tamper with Vouch CLI binaries** during build or distribution, leading to **malicious code execution** on developer workstations. | Tampering | Critical |

</div>

**Mitigations:**

- **T-T1**: All CLI-to-server communication uses TLS 1.2+. DPoP ([RFC 9449](https://datatracker.ietf.org/doc/html/rfc9449)) binds tokens to the client's key pair — intercepted tokens cannot be used from a different machine. PAR ([RFC 9126](https://datatracker.ietf.org/doc/html/rfc9126)) transmits authorization parameters server-side, keeping sensitive data out of URLs and browser history.
- **T-T2**: Server access is restricted by infrastructure controls (network isolation, access auditing). The server does not store external service credentials — it brokers them on demand. Compromise allows credential issuance but not direct access to AWS keys or SSH private keys. → [Shared responsibility](/docs/security/#shared-responsibility)
- **T-T3**: Release binaries include [SLSA Level 3](https://slsa.dev/) provenance attestations and SHA256 checksums. Package manager installs (Homebrew, APT, DNF) verify signatures automatically. → [Supply chain security](/docs/security/#supply-chain-security)

---

### Repudiation

<div class="threat-table">

| ID | Threat | STRIDE | Severity |
|---|---|---|---|
| **T-R1** | A **malicious insider** can **deny performing an action** (e.g., accessing a production resource) if audit logs are insufficient, leading to **inability to attribute actions** during incident response. | Repudiation | Medium |
| **T-R2** | A **compromised server** can **tamper with or delete audit logs**, leading to **loss of forensic evidence**. | Repudiation | High |

</div>

**Mitigations:**

- **T-R1**: Every credential issuance is tied to a hardware-verified FIDO2 identity. The Vouch server logs all authentication events and credential exchanges. AWS CloudTrail records STS credential usage with the Vouch-issued identity as the principal.
- **T-R2**: Audit logs should be exported to an immutable, external log store (e.g., AWS CloudWatch, a SIEM) so that server compromise cannot erase the trail. → [Shared responsibility](/docs/security/#shared-responsibility)

---

### Information disclosure

<div class="threat-table">

| ID | Threat | STRIDE | Severity |
|---|---|---|---|
| **T-I1** | A **compromised endpoint** with code execution as the local user can **read the Vouch agent's process memory**, leading to **theft of the active session token and cached credentials**. | Information disclosure | High |
| **T-I2** | An **external attacker** who compromises a network intermediary can **observe credential exchange traffic**, leading to **exposure of tokens or credentials**. | Information disclosure | High |
| **T-I3** | An **external attacker** can **enumerate the OIDC discovery endpoint** (`/.well-known/openid-configuration`) to **learn the server's signing keys and supported configuration**, leading to **information useful for targeted attacks**. | Information disclosure | Low |

</div>

**Mitigations:**

- **T-I1**: DPoP binds tokens to the CLI's key pair — stolen tokens cannot be used from a different machine. Credentials are never written to disk (no `~/.aws/credentials`, no `~/.ssh/id_*`). Session lifetime is limited to 8 hours, and AWS STS credentials expire within 1 hour. Full endpoint compromise with kernel access is out of scope (see [assumption A5](#assumptions)).
- **T-I2**: TLS 1.2+ encrypts all traffic in transit. DPoP provides an additional layer — even if a token is somehow intercepted, it cannot be replayed from another client.
- **T-I3**: OIDC discovery is public by design (required for AWS OIDC federation). The exposed information (issuer URL, JWKS, supported algorithms) does not enable impersonation. Private keys are never exposed through these endpoints.

---

### Denial of service

<div class="threat-table">

| ID | Threat | STRIDE | Severity |
|---|---|---|---|
| **T-D1** | An **external attacker** can **flood the Vouch server** with authentication requests, leading to **developers being unable to obtain credentials**. | Denial of service | Medium |
| **T-D2** | An **external attacker** can **disrupt network connectivity** between the CLI and the Vouch server, leading to **inability to establish new sessions or obtain fresh credentials**. | Denial of service | Medium |

</div>

**Mitigations:**

- **T-D1**: The Vouch server implements rate limiting and is deployed behind infrastructure-level DDoS protection. Authentication requires a valid FIDO2 assertion, making automated abuse expensive.
- **T-D2**: Cached credentials remain valid for their remaining lifetime (up to 8 hours for sessions, 1 hour for AWS STS). Developers can continue working with existing credentials during an outage. → [Availability and Failure Modes](/docs/availability/)

---

### Elevation of privilege

<div class="threat-table">

| ID | Threat | STRIDE | Severity |
|---|---|---|---|
| **T-E1** | A **compromised endpoint** can **access the Unix domain socket** and **use the active session to request credentials for any role the user is authorized for**, leading to **unauthorized access to cloud resources** within the user's permission set. | Elevation of privilege | High |
| **T-E2** | A **malicious insider** can **use their valid Vouch session to access resources beyond their intended scope** if IAM roles are overly permissive, leading to **unauthorized access to production systems or sensitive data**. | Elevation of privilege | High |
| **T-E3** | A **compromised server** can **issue sessions for any enrolled user**, leading to **impersonation of any developer** and access to their authorized resources. | Elevation of privilege | Critical |

</div>

**Mitigations:**

- **T-E1**: The Unix socket is restricted to the owning user by filesystem permissions. DPoP prevents extracted tokens from being used on a different machine. Credential scope is limited to the user's authorized roles — the attacker cannot escalate beyond what the user could already access. This threat is bounded by session lifetime (8 hours) and credential lifetime (≤1 hour).
- **T-E2**: IAM roles should follow least-privilege principles. Vouch enables fine-grained role mapping per user via OIDC claims. CloudTrail provides full attribution of which user assumed which role. → [Shared responsibility](/docs/security/#shared-responsibility)
- **T-E3**: Server infrastructure must be hardened with network isolation, encrypted storage, audited access, and minimal attack surface. The server does not store external credentials — it brokers them — so compromise enables credential issuance but not direct access to secrets at rest.

---

## Mitigation summary

| Control | Threats addressed | Layer |
|---|---|---|
| **FIDO2 origin binding** | T-S1 (phishing) | Hardware |
| **FIDO2 user verification (PIN + touch)** | T-S2 (stolen key) | Hardware |
| **DPoP sender-constrained tokens** | T-T1, T-I1, T-I2, T-E1 (token theft, replay) | Protocol |
| **PAR + signed JWTs** | T-T1 (parameter injection) | Protocol |
| **TLS 1.2+** | T-T1, T-I2 (network interception) | Transport |
| **In-memory only credentials** | T-I1 (disk exfiltration) | Application |
| **Short credential lifetimes** | T-S3, T-I1, T-E1 (blast radius) | Application |
| **SCIM de-provisioning** | T-S3 (offboarding) | Identity |
| **OIDC audience restriction** | T-E2 (cross-service abuse) | Protocol |
| **SLSA Level 3 provenance** | T-T3 (supply chain) | Build |
| **Audit logging + CloudTrail** | T-R1, T-R2 (repudiation) | Operational |
| **Rate limiting + DDoS protection** | T-D1 (server flood) | Infrastructure |
| **Credential caching** | T-D2 (outage resilience) | Application |

---

## Out of scope

The following threats are explicitly out of scope for this threat model:

| Threat | Rationale |
|---|---|
| **Kernel-level endpoint compromise** | If an attacker has root/kernel access, all user-space isolation (process memory, socket permissions) is bypassed. Endpoint detection and response (EDR) tools are the appropriate mitigation layer. |
| **Vulnerabilities in external services** | AWS STS, GitHub APIs, container registries, and SSH implementations have their own security models. Vouch trusts their documented behavior. |
| **Cryptographic breaks** | If ECDSA (P-256), Ed25519, or TLS 1.2+ are broken, the impact extends far beyond Vouch. |
| **Physical coercion** | An attacker who can physically compel a developer to authenticate is outside the scope of a technical threat model. |
| **YubiKey hardware vulnerabilities** | Vouch trusts the FIDO2 implementation of enrolled authenticators. Hardware side-channel attacks on the YubiKey secure element are outside scope. |

---

## Revision history

| Date | Change |
|---|---|
| 2026-02-28 | Initial threat model published on vouch.sh, structured using STRIDE and the AWS Threat Composer methodology. |



---

# Architecture Overview

Source: https://vouch.sh/docs/architecture/


This page describes the components that make up Vouch, the protocols they use, and how they interact to turn a YubiKey tap into short-lived credentials for SSH, AWS, GitHub, Docker, and more.

---

## Components

### Vouch CLI (`vouch`)

The command-line interface that developers interact with directly. It handles:

- **Enrollment** -- Registers a FIDO2 key with the Vouch server.
- **Login** -- Performs a FIDO2 assertion and establishes a session.
- **Credential helpers** -- Provides credentials to tools like `aws`, `git`, `ssh`, `docker`, and `cargo` on demand.
- **Setup commands** -- Configures local tool integrations (`vouch setup aws`, `vouch setup codecommit`, etc.).

The CLI communicates with the Vouch agent over a local Unix domain socket and with the Vouch server over HTTPS.

### Vouch Agent

A background process that holds session state in memory. The agent:

- **Caches the active session** so that credential requests do not require repeated FIDO2 assertions.
- **Serves as an SSH agent** (implementing the SSH agent protocol) so that `ssh` can request certificates without additional configuration.
- **Listens on a Unix domain socket** with filesystem permissions restricting access to the owning user.
- **Holds no persistent state** -- if the agent process stops, the session is lost and a new `vouch login` is required.

On macOS, the agent runs as a Homebrew service (`brew services start vouch`). On Linux, it runs as a systemd user service.

### Vouch Server

The server is the identity broker. It:

- **Validates FIDO2 assertions** against enrolled public keys.
- **Issues OIDC ID tokens** (signed with ES256) that AWS and other services consume via standard OIDC federation.
- **Signs SSH certificates** using an Ed25519 certificate authority key.
- **Exchanges tokens** with GitHub Apps, AWS STS, and other external services on behalf of authenticated users.
- **Manages the user directory** via SCIM 2.0 integration with identity providers.
- **Publishes OIDC metadata** at `/.well-known/openid-configuration` and JWKS at `/.well-known/jwks.json` for external services to verify tokens.

The server does not store AWS credentials, SSH private keys, or GitHub tokens. It brokers short-lived credentials from external services.

---

## Protocol details

### FIDO2 / WebAuthn

Used for all user authentication. The FIDO2 exchange happens between the YubiKey (authenticator), the Vouch CLI (client), and the Vouch server (relying party).

- **Registration** (enrollment): The YubiKey generates a key pair. The public key is sent to the server. The private key never leaves the hardware.
- **Authentication** (login): The server sends a challenge. The YubiKey signs it with the private key after PIN + touch verification. The server validates the signature against the stored public key.

### OIDC (OpenID Connect)

The Vouch server acts as an OIDC identity provider. After FIDO2 authentication, it issues a signed JWT (ID token) containing:

| Claim | Description |
|---|---|
| `iss` | Vouch server URL (e.g., `https://us.vouch.sh`) |
| `sub` | User's email address |
| `aud` | Vouch server URL (used as the OIDC client ID) |
| `exp` | Token expiration (short-lived) |
| `iat` | Token issued-at timestamp |
| `hd` | Google Workspace hosted domain |
| `amr` | Authentication methods (e.g., `["hwk", "pin"]`) |
| `acr` | Authentication context class (NIST AAL3) |
| `cnf` | DPoP key thumbprint for sender-constrained tokens |

External services (AWS, custom OIDC applications) validate these tokens using the Vouch server's JWKS endpoint.

### ES256 (ECDSA over P-256)

Used to sign OIDC ID tokens. External services fetch the public key from `/.well-known/jwks.json` to verify token signatures.

### Ed25519

Used for SSH certificate signing. The Vouch server holds an Ed25519 CA key and signs SSH certificates that include the user's identity as a principal.

### SSH Agent Protocol

The Vouch agent implements the [SSH agent protocol](https://datatracker.ietf.org/doc/html/draft-miller-ssh-agent), making certificates available to `ssh` via the `SSH_AUTH_SOCK` environment variable. This is the same protocol used by `ssh-agent` and compatible with all standard SSH clients.

### AWS STS (AssumeRoleWithWebIdentity)

The Vouch CLI calls [AssumeRoleWithWebIdentity](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html) with the OIDC ID token. AWS validates the token against the Vouch JWKS endpoint and returns temporary credentials (access key ID, secret access key, session token).

### FAPI 2.0

The Vouch CLI operates as a [FAPI 2.0](https://openid.net/specs/fapi-security-profile-2_0-final.html) client. On first use, it generates an ES256 key pair, stores it in the OS keychain, and auto-registers with the server ([RFC 7591](https://datatracker.ietf.org/doc/html/rfc7591)). Token requests use DPoP ([RFC 9449](https://datatracker.ietf.org/doc/html/rfc9449)) for sender-constrained tokens, PAR ([RFC 9126](https://datatracker.ietf.org/doc/html/rfc9126)) for protected authorization requests, and `private_key_jwt` ([RFC 7523](https://datatracker.ietf.org/doc/html/rfc7523)) for client authentication — no shared secrets between CLI and server.

### SCIM 2.0

The Vouch server implements [SCIM 2.0](https://datatracker.ietf.org/doc/html/rfc7644) endpoints for automated user provisioning. Identity providers (Google Workspace, Okta, Azure AD) push user lifecycle events to synchronize the Vouch user directory.

---

## Authentication flow

The complete flow from YubiKey tap to credential consumption:

```
┌──────────┐    ┌──────────┐    ┌──────────────┐    ┌─────────────────┐
│  YubiKey  │    │ Vouch CLI│    │ Vouch Server │    │ External Service│
│  (FIDO2)  │    │ + Agent  │    │  (IdP/CA)    │    │(AWS/GitHub/etc.)│
└─────┬────┘    └─────┬────┘    └──────┬───────┘    └───────┬─────────┘
      │               │               │                    │
      │  1. Challenge  │               │                    │
      │◄──────────────┤  Get challenge │                    │
      │               ├──────────────►│                    │
      │               │               │                    │
      │  2. Sign       │               │                    │
      │  (PIN+touch)  │               │                    │
      ├──────────────►│               │                    │
      │               │  3. Assertion  │                    │
      │               ├──────────────►│                    │
      │               │               │  4. Validate       │
      │               │               │                    │
      │               │  5. Session    │                    │
      │               │◄──────────────┤                    │
      │               │               │                    │
      │               │  6. Credential │                    │
      │               │     request   │                    │
      │               ├──────────────►│                    │
      │               │               │  7. Exchange       │
      │               │               ├──────────────────►│
      │               │               │  8. Short-lived    │
      │               │               │◄──────────────────┤
      │               │  9. Credential │                    │
      │               │◄──────────────┤                    │
      │               │               │                    │
      │               │  10. Tool uses │                    │
      │               │     credential │                    │
      │               ├──────────────────────────────────►│
```

Steps 1--5 happen once during `vouch login`. Steps 6--10 happen on demand each time a tool needs a credential.

---

## Agent architecture

The Vouch agent is a long-running process that provides two services:

### Unix domain socket

The CLI communicates with the agent over a Unix domain socket at a well-known path. The socket file has restrictive permissions (owner-only) to prevent other users on the system from accessing session material.

### In-memory credential cache

The agent caches:

- **Session token** -- Used to authenticate requests to the Vouch server.
- **SSH certificate** -- Served to SSH clients via the agent protocol.
- **Cached STS credentials** -- AWS credentials are cached until their 1-hour expiry to avoid redundant STS calls.

All cached material is held in process memory. Nothing is written to disk. When the agent process stops (logout, reboot, crash), all cached credentials are lost and a new `vouch login` is required.

---

## Network requirements

The Vouch CLI and agent need to reach the following endpoints:

| Destination | Port | Protocol | Purpose |
|---|---|---|---|
| Vouch server (e.g., `us.vouch.sh`) | 443 | HTTPS | Authentication, credential exchange, OIDC |
| AWS STS (`sts.amazonaws.com`) | 443 | HTTPS | `AssumeRoleWithWebIdentity` |
| GitHub API (`api.github.com`) | 443 | HTTPS | Installation token exchange (if GitHub integration is used) |
| Target SSH hosts | 22 | SSH | SSH connections (if SSH integration is used) |

The Vouch server must be reachable from the internet so that AWS can fetch the JWKS endpoint for token validation. If your organization uses a firewall or proxy, ensure these destinations are allowed.

---

## Data residency

Vouch server instances are deployed in specific geographic regions:

| Instance | Region | Status |
|---|---|---|
| `us.vouch.sh` | United States | Active |
| EU instance | Europe | Coming soon |
| APAC instance | Asia-Pacific | Coming soon |

All user data (enrolled keys, user metadata, audit logs) resides in the region of the Vouch server instance you enroll with. Credentials brokered through AWS STS, GitHub, and other external services are subject to those services' own data residency policies.



---

# Availability and Failure Modes

Source: https://vouch.sh/docs/availability/


Vouch sits in the critical path for developer credentials. Before adopting it, you should understand what happens when the server is unreachable, when a session expires, or when individual integrations fail.

---

## Normal operation

During normal operation with an active session (up to 8 hours after `vouch login`):

| Integration | Credential source | Lifetime |
|---|---|---|
| SSH | Certificate cached in agent memory | 8 hours |
| AWS (`credential_process`) | STS credentials fetched on demand, cached | 1 hour |
| GitHub | Installation token fetched on demand | 1 hour |
| Docker (ECR) | Registry token fetched on demand | 12 hours |
| Docker (GHCR) | GitHub token fetched on demand | 1 hour |
| CodeCommit | SigV4 signature computed on demand | Per-request |
| CodeArtifact | Authorization token fetched on demand | 12 hours |
| Cargo | Token fetched on demand | Session lifetime |

---

## Offline behavior

### Server unreachable during active session

If the Vouch server becomes unreachable while you have an active session:

| What works | Why |
|---|---|
| **SSH connections** | The SSH certificate is cached in the agent's memory. It remains valid until it expires (up to 8 hours from login). No server contact is needed. |
| **AWS commands** | Cached STS credentials remain valid until their 1-hour expiry. If cached credentials exist, `credential_process` returns them without contacting the server. |
| **Docker pulls** (with cached token) | ECR tokens last up to 12 hours and are cached locally by Docker. |

| What fails | Why |
|---|---|
| **New AWS credential requests** (after cache expires) | `credential_process` calls `vouch credential aws`, which needs to exchange the session for fresh STS credentials via the server. |
| **New GitHub token requests** | GitHub installation tokens are fetched through the server. |
| **New CodeArtifact tokens** | Token exchange requires server communication. |
| **`vouch login`** | A new login always requires the server for FIDO2 validation. |

**Key point:** An active session with cached credentials continues working without server contact. The impact of a server outage depends on when cached credentials expire. In the worst case, you have up to 1 hour of AWS access and up to 8 hours of SSH access after the server goes down.

### Server unreachable with no active session

If the Vouch server is unreachable and you have no active session (e.g., at the start of a workday), you cannot authenticate. No new credentials can be obtained.

**Mitigation:** Break-glass access. Maintain a separate emergency access path (e.g., an IAM user with MFA in a sealed envelope, or AWS root account credentials in a hardware security module) for situations where Vouch is unavailable and critical access is needed.

---

## Session expiry

When your 8-hour session expires:

- **SSH connections** in progress continue until they are closed (the certificate was already presented during connection setup).
- **New SSH connections** fail because the certificate has expired.
- **AWS commands** continue working until the cached STS credentials expire (up to 1 hour after the last credential fetch).
- **New credential requests** of all types fail until you run `vouch login` again.

This is by design. Short session lifetimes limit the window of exposure if a machine is compromised.

---

## Credential helper failure modes

### `credential_process` (AWS)

The AWS CLI and SDKs call `vouch credential aws` via the `credential_process` configuration. If this command fails:

- The AWS CLI prints an error: `Error when retrieving credentials from custom-process`.
- The command does not fall back to other credential sources in the same profile. However, if you have other AWS profiles configured (e.g., a fallback profile with static keys), you can switch profiles.
- **Important:** `credential_process` errors do not cache. Each AWS command retries the credential process independently.

### SSH agent

If the Vouch agent is not running:

- `ssh` falls back to the next available authentication method (other SSH agents, keys in `~/.ssh/`, password authentication) depending on your SSH configuration.
- If no fallback is configured, the connection fails with `Permission denied`.

### Git credential helper

If the Vouch Git credential helper fails (for GitHub or CodeCommit):

- Git prompts for a username and password, or fails with `Authentication failed` depending on the remote configuration.
- This does not affect other Git remotes that do not use Vouch.

---

## De-provisioning timeline

When a user is de-provisioned (via SCIM or manual removal):

| Time | Effect |
|---|---|
| **Immediately** | Active sessions are revoked on the server. New credential requests fail. |
| **Within 1 hour** | Cached AWS STS credentials expire. AWS access stops. |
| **Within 8 hours** | SSH certificate expires. SSH access stops. |
| **Within 12 hours** | Cached ECR/CodeArtifact tokens expire. |

The maximum exposure window after de-provisioning is the longest credential lifetime (currently 12 hours for ECR tokens). For most integrations, access ends within 1 hour.

---

## Status and monitoring

Check the Vouch server's operational status:

- **Status page:** Contact your Vouch server administrator for status page URL.
- **CLI health check:** `vouch status` reports whether the agent is running and whether the current session is valid.

---

## Planning for failure

### Recommendations

1. **Establish break-glass procedures** before rolling out Vouch. Document an emergency access path that does not depend on Vouch.
2. **Stagger session starts** across the team. If everyone logs in at 9 AM, everyone's sessions expire at 5 PM. Consider encouraging re-login before critical deployments.
3. **Monitor `vouch login` failures** as an early warning of server issues.
4. **Keep the Vouch agent running** to preserve cached credentials across CLI invocations. On macOS, use `brew services`. On Linux, use systemd.
5. **Test credential expiry** in a non-production environment so the team knows what failure looks like before it happens in production.



---

# Migration Guide

Source: https://vouch.sh/docs/migration/


Migrating to Vouch does not have to be all-or-nothing. You can install Vouch alongside your existing credentials and migrate one integration at a time. This guide walks through a phased rollout, a per-integration checklist, and a rollback plan.

---

## Phase 1 -- Install and enroll

Install the Vouch CLI alongside your existing credential setup. Nothing changes yet.

1. **Install the CLI** on each developer's machine. See [Getting Started](/docs/getting-started/).
2. **Enroll YubiKeys** with the Vouch server. Each developer runs `vouch enroll`.
3. **Test login.** Each developer runs `vouch login` and verifies they can authenticate.

At this point, Vouch is installed but no integrations are active. Existing SSH keys, AWS access keys, and GitHub PATs continue to work as before.

---

## Phase 2 -- Migrate integrations one at a time

Pick one integration to migrate first. AWS is recommended because `credential_process` works alongside existing credentials without conflict.

### Migration order (recommended)

| Order | Integration | Why first/last |
|---|---|---|
| 1 | **AWS** | `credential_process` adds a new profile. Existing profiles and access keys are unaffected. |
| 2 | **SSH** | Vouch SSH certificates work alongside existing SSH keys. The SSH agent falls back to keys if the certificate is unavailable. |
| 3 | **GitHub** | Git credential helpers can be stacked. Vouch adds a new helper without removing existing ones. |
| 4 | **Docker** | Docker credential helpers can be configured per registry. Migrate one registry at a time. |
| 5 | **CodeCommit** | Requires AWS integration to be working first. |
| 6 | **CodeArtifact** | Requires AWS integration to be working first. |
| 7 | **EKS** | Requires AWS integration and `kubectl` configuration. |
| 8 | **Databases** | Requires AWS integration and application-level changes for IAM auth. |

### Per-integration checklist

For each integration:

- [ ] **Configure the integration** using `vouch setup <integration>`.
- [ ] **Test with one developer** before rolling out to the team.
- [ ] **Verify the tool works** with Vouch credentials (e.g., `aws s3 ls --profile vouch`, `ssh user@server`, `git push`).
- [ ] **Run for one week** with both Vouch and static credentials available.
- [ ] **Migrate the rest of the team** once the pilot developer confirms it works.

---

## Phase 3 -- Revoke old credentials

After each integration is working with Vouch for the entire team, revoke the static credentials it replaced:

### AWS access keys

```bash
# List existing access keys
aws iam list-access-keys --user-name alice

# Deactivate first (in case you need to re-enable)
aws iam update-access-key --user-name alice --access-key-id AKIAXXXXXXXX --status Inactive

# Delete after confirming everything works
aws iam delete-access-key --user-name alice --access-key-id AKIAXXXXXXXX
```

Check `~/.aws/credentials` on each developer's machine and remove static entries.

### SSH keys

1. Remove old public keys from `~/.ssh/authorized_keys` on servers (or from your configuration management tool).
2. Keep the Vouch CA public key as the only trusted signer in `sshd_config`.
3. Developers can keep their SSH key files locally as a fallback, or remove them.

### GitHub PATs

1. Navigate to GitHub **Settings > Developer settings > Personal access tokens**.
2. Revoke tokens that were used for repository access.
3. Verify that `git push` still works with the Vouch credential helper.

### Docker credentials

1. Check `~/.docker/config.json` for stored registry credentials.
2. Remove entries for registries now handled by Vouch.

---

## CI/CD considerations

CI/CD pipelines typically do not have YubiKeys. They will continue to use their existing credential mechanisms:

| CI/CD pattern | Recommendation |
|---|---|
| **GitHub Actions** | Use OIDC federation with GitHub's built-in OIDC provider (`token.actions.githubusercontent.com`). This is separate from Vouch and provides the same STS-based authentication for pipelines. |
| **AWS CodeBuild / CodePipeline** | Use IAM roles attached to the build environment. No static keys needed. |
| **Jenkins / GitLab CI** | Use IAM roles if running on EC2, or [Vouch CI/CD integration](/docs/cicd/) for human approval gates. |
| **Static keys in CI/CD** | If your pipeline currently uses static AWS keys, keep them for now. Replace them with OIDC federation (GitHub Actions) or IAM roles (EC2-based runners) as a separate project. |

Vouch's [CI/CD integration](/docs/cicd/) is designed for human approval gates (e.g., requiring a YubiKey tap before a production deployment), not for replacing machine credentials in automated pipelines.

---

## Rollback plan

If you need to revert to static credentials for any integration:

### AWS

1. Re-enable or re-create IAM access keys for affected users.
2. Update `~/.aws/credentials` with the static keys.
3. Remove or comment out the `credential_process` line in `~/.aws/config` for the Vouch profile.

### SSH

1. Re-add public keys to `~/.ssh/authorized_keys` on servers.
2. Ensure `IdentityFile` entries in `~/.ssh/config` point to the static keys.
3. SSH falls back to keys automatically if the Vouch certificate is unavailable.

### GitHub

1. Generate a new GitHub PAT.
2. Update the Git credential helper or set `GIT_ASKPASS` to use the PAT.
3. Remove the Vouch credential helper entry from `~/.gitconfig`.

### Docker

1. Run `docker login <registry>` with static credentials.
2. Remove the Vouch credential helper from `~/.docker/config.json`.

---

## Verification checklist

After completing migration for all integrations:

- [ ] All developers can `vouch login` and access all required services.
- [ ] No static AWS access keys remain active in IAM.
- [ ] No static SSH keys remain in `authorized_keys` (only the Vouch CA is trusted).
- [ ] No GitHub PATs remain active.
- [ ] CI/CD pipelines continue to function with their own credential mechanisms.
- [ ] SCIM provisioning is configured for automated onboarding/offboarding (recommended for teams > 15 people).
- [ ] Break-glass procedures are documented for emergency access without Vouch. See [Availability](/docs/availability/).



---

# Frequently Asked Questions

Source: https://vouch.sh/docs/faq/


## Hardware keys

### Which YubiKeys are supported?

Any **FIDO2-compatible** security key works with Vouch. Recommended models:

- **YubiKey 5 series** (5 NFC, 5C, 5C NFC, 5Ci, 5C Nano, 5 Nano) -- Recommended. Supports FIDO2, USB-A or USB-C.
- **YubiKey 5 FIPS series** -- Same as above, with FIPS 140-2 validation.
- **YubiKey Bio** -- Supports FIDO2 with fingerprint biometrics instead of PIN.
- **Security Key by Yubico** (NFC or C NFC) -- Budget option. Supports FIDO2 but lacks other YubiKey features (PIV, OpenPGP).

Other FIDO2-compliant keys (e.g., Google Titan, Feitian, SoloKeys) may work but have not been tested. The key must support the `hmac-secret` extension and resident credentials.

### What happens if I lose my YubiKey?

1. **Report it immediately** to your organization administrator so they can remove the key from your account.
2. Your active session (if any) continues until it expires (up to 8 hours), but no new sessions can be created with the lost key.
3. Enroll a new YubiKey by running `vouch enroll` again.
4. If you have a backup key already enrolled, use that key to log in while you replace the lost one.

### Can I enroll multiple YubiKeys?

Yes. Run `vouch enroll` with each key. This is recommended so you have a backup in case one key is lost or damaged. All enrolled keys can be used interchangeably for `vouch login`.

### Can I use the same YubiKey across multiple Vouch organizations?

Yes. A single YubiKey can hold multiple FIDO2 credentials. Enroll the key with each organization's Vouch server and it will work with all of them.

---

## Sessions and credentials

### How long does a session last?

Sessions last **8 hours** from the time you run `vouch login`. After 8 hours, the session expires and you need to log in again. There is no way to extend a session -- you must re-authenticate with your YubiKey.

### How long do AWS credentials last?

AWS STS credentials obtained through Vouch are valid for up to **1 hour**. The Vouch agent caches them, and when they expire, a new set is fetched automatically (as long as your session is active). You do not need to take any action.

### What happens when my session expires mid-task?

- **SSH connections** already established continue to work. New connections will fail.
- **AWS commands** fail with a credential error. Run `vouch login` and retry.
- **Git operations** fail if they require authentication. Run `vouch login` and retry.
- **Long-running processes** (e.g., `terraform apply`, `cdk deploy`) that started with valid credentials will continue until they need to refresh credentials. If a refresh fails mid-operation, the process may fail partially.

### Are credentials written to disk?

No. All credentials are held in the Vouch agent's process memory. The session token, SSH certificate, and cached STS credentials are never written to a file. If the agent process stops, all credentials are lost.

### Does Vouch work with `aws-vault`?

Vouch replaces the need for `aws-vault`. Both tools solve the same problem (avoiding static AWS credentials), but they work differently. You should use one or the other, not both. If you are currently using `aws-vault`, see the [Migration Guide](/docs/migration/) for switching to Vouch.

---

## Platform support

### Does Vouch work on Windows?

Windows support is limited. The following commands work on Windows:

- `vouch enroll`
- `vouch login`
- `vouch credential aws`
- `vouch credential github`

The SSH agent and SSH certificate integration are **not available** on Windows. The background agent service is also not available -- credentials are obtained directly by each command invocation.

### Does Vouch work on Linux?

Yes. Vouch supports Debian/Ubuntu (APT) and Fedora/RHEL (DNF). The agent runs as a systemd user service. See [Getting Started](/docs/getting-started/) for installation instructions.

### Does Vouch work in WSL?

WSL (Windows Subsystem for Linux) works the same as native Linux. Install the Linux version of the CLI and use USB passthrough for YubiKey access.

### Does Vouch work in containers?

Vouch is designed for developer workstations, not containers. For containers in CI/CD pipelines, use the pipeline's native credential mechanism (e.g., GitHub Actions OIDC, IAM roles for ECS tasks). See [CI/CD Integration](/docs/cicd/) for human approval gates.

---

## AWS

### Does Vouch use AWS STS? Is there a cost?

Yes, Vouch calls [AssumeRoleWithWebIdentity](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRoleWithWebIdentity.html) to obtain temporary credentials. **AWS STS is free** -- there is no charge for STS API calls.

### What appears in CloudTrail?

Every API call made with Vouch credentials appears in CloudTrail with the assumed role session name set to the developer's email address:

```
arn:aws:sts::123456789012:assumed-role/VouchDeveloper/alice@example.com
```

This provides full per-user attribution for AWS API activity.

### Can I use Vouch with multiple AWS accounts?

Yes. See [Multi-Account AWS Strategy](/docs/aws-multi-account/) for deployment patterns using CloudFormation StackSets or Terraform modules.

### Does Vouch support AWS GovCloud?

Vouch supports standard and China partitions. GovCloud support depends on the integration -- check the specific integration documentation page for cross-partition details.

---

## Identity and access

### Which identity providers does Vouch support?

Vouch currently supports **Google Workspace** as the primary identity provider for user authentication. For automated user provisioning (SCIM), Vouch works with Google Workspace, Okta, Azure AD (Entra ID), and OneLogin.

### What happens when someone leaves the company?

If SCIM is configured: deactivating the user in your identity provider automatically revokes their Vouch sessions. See [SCIM Provisioning](/docs/scim/).

If SCIM is not configured: an administrator must manually remove the user from the Vouch server. Their active session is revoked immediately. Outstanding short-lived credentials expire on their own (within 8 hours at most).

### Can I restrict which team members can assume specific AWS roles?

Yes. Use IAM trust policy conditions to restrict role assumption by email address or domain. See [Restricting access](/docs/aws/#tips-for-restricting-access) in the AWS documentation.

---

## Security

### Is Vouch open source?

The Vouch CLI is open source. The server is operated as a managed service.

### What data does the Vouch server store?

The server stores enrolled FIDO2 public keys, user metadata (email, organization membership), and audit logs. It does not store AWS credentials, SSH private keys, GitHub tokens, or any other secrets. See [Security](/docs/security/) for details.

### What happens if the Vouch server is compromised?

An attacker with server access could issue sessions for any enrolled user, which could be used to broker credentials from external services (AWS, GitHub, etc.). However, the server does not store any credentials itself -- there is no credential vault to extract. See the [threat model](/docs/security/#threat-model) for the full analysis.

### Are credentials encrypted in transit?

Yes. All communication between the CLI and server uses TLS 1.2+. See [Security](/docs/security/#encryption) for details.

---

## Troubleshooting

### "Error: agent not running"

Start the Vouch agent:

- **macOS:** `brew services start vouch`
- **Linux:** `systemctl --user start vouch`

### "Error: no active session"

Run `vouch login` and authenticate with your YubiKey.

### "Error: credential_process returned error"

This typically means your Vouch session has expired or the agent is not running. Run `vouch login` to re-authenticate.

### Where can I get help?

- **Documentation:** [vouch.sh/docs](/docs/)
- **GitHub Issues:** [github.com/vouch-sh/vouch/issues](https://github.com/vouch-sh/vouch/issues)
- **Security issues:** Email security@vouch.sh



---

# Vouch for Startups

Source: https://vouch.sh/docs/startups/


You just created an AWS account. Every tutorial says "create an IAM user." Don't.

IAM users come with long-lived access keys that never expire, get committed to Git, leaked in logs, and compromised by malware. Rotating them is a manual chore. When someone leaves, you have to hunt down every key they ever created. And none of this is necessary -- AWS supports OIDC federation, which means you can authenticate with the identity system your team already uses.

If your team uses **Google Workspace**, Vouch bridges it directly into AWS. One `vouch login` gives every developer short-lived credentials for AWS, SSH, GitHub, Docker registries, and more -- all tied to their Google Workspace identity, all backed by a hardware key.

---

## What you get

After following this guide, your team will have:

- **No IAM users** -- Every developer authenticates with their Google Workspace account + YubiKey.
- **No access keys** -- AWS credentials are temporary (1 hour) and never written to disk.
- **No credential files** -- No `~/.aws/credentials`, no SSH keys to distribute, no GitHub PATs.
- **Instant offboarding** -- When someone's Google Workspace account is deactivated, their AWS access ends immediately.
- **Full audit trail** -- Every AWS API call in CloudTrail shows which developer made it.

---

## Why not IAM Identity Center?

[AWS IAM Identity Center](https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html) (formerly AWS SSO) is AWS's own solution for federated access. It's a good product, but it's designed for enterprises with dozens of accounts and hundreds of users. For a startup:

| Consideration | IAM Identity Center | Vouch |
|---|---|---|
| **Setup complexity** | Requires an AWS Organizations management account, an Identity Center instance, permission sets, and user/group sync | Deploy one CloudFormation template and run `vouch setup aws` |
| **Scope** | AWS only | AWS + SSH + GitHub + Docker + CodeCommit + CodeArtifact + databases + more |
| **Authentication** | Browser-based SSO (MFA depends on IdP config) | FIDO2 hardware key (phishing-resistant by design) |
| **Team size sweet spot** | 20+ people across multiple accounts | 2--50 people |
| **Credential type** | Session credentials via `aws sso login` | Session credentials via `vouch login` |

If you have a large organization with complex permission requirements across many AWS accounts, IAM Identity Center is the right choice. If you are a startup that wants secure AWS access without the overhead, Vouch gets you there faster.

## Why not AWS Builder ID?

[AWS Builder ID](https://docs.aws.amazon.com/signin/latest/userguide/sign-in-aws_builder_id.html) provides individual developer identity for AWS services. The key difference: Builder ID is **individual** identity, not **organizational** identity. It does not know about your Google Workspace domain, your team structure, or your offboarding process. You cannot restrict AWS access to "people who work at my company" using Builder ID alone.

Vouch federates your organization's identity (Google Workspace domain) into AWS, so access is tied to employment by design.

---

## Step 1 -- Get YubiKeys for the team

Order [YubiKey 5 series](https://www.yubico.com/products/yubikey-5-overview/) keys for each team member. Any FIDO2-compatible security key works, but YubiKey 5 series is recommended.

---

## Step 2 -- Enroll the team

The first person to log into Vouch from your Google Workspace domain becomes the organization owner.

**Owner enrollment:**

```bash
# Install the CLI
brew install vouch-sh/tap/vouch
brew services start vouch

# Enroll (first person becomes the org owner)
vouch enroll --server https://{{< instance-url >}}
```

**Team member enrollment:**

Each team member installs the CLI and enrolls with the same server:

```bash
brew install vouch-sh/tap/vouch
brew services start vouch
vouch enroll --server https://{{< instance-url >}}
```

As long as they authenticate with the same Google Workspace domain, they join the same organization. No invite codes or admin approval needed for initial enrollment.

---

## Step 3 -- Deploy the AWS OIDC provider

Deploy a single CloudFormation template to register Vouch as an OIDC identity provider in your AWS account and create an IAM role for your team:

```yaml
AWSTemplateFormatVersion: "2010-09-09"
Description: "Vouch OIDC Federation — one-click setup for startups"

Parameters:
  VouchServerUrl:
    Type: String
    Default: "{{< instance-url >}}"
    Description: "Vouch server hostname (without https://)"

Resources:
  VouchOIDCProvider:
    Type: AWS::IAM::OIDCProvider
    Properties:
      Url: !Sub "https://${VouchServerUrl}"
      ClientIdList:
        - !Sub "https://${VouchServerUrl}"

  VouchDeveloperRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: VouchDeveloper
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Federated: !Sub "arn:aws:iam::${AWS::AccountId}:oidc-provider/${VouchServerUrl}"
            Action: "sts:AssumeRoleWithWebIdentity"
            Condition:
              StringEquals:
                !Sub "${VouchServerUrl}:aud": !Sub "https://${VouchServerUrl}"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/PowerUserAccess

Outputs:
  RoleArn:
    Value: !GetAtt VouchDeveloperRole.Arn
    Description: "Use this ARN with 'vouch setup aws --role <ARN>'"
```

Deploy it:

```bash
aws cloudformation deploy \
  --template-file vouch-startup.yaml \
  --stack-name vouch-federation \
  --capabilities CAPABILITY_NAMED_IAM
```

> **Note:** This template uses `PowerUserAccess` as a starting point. Adjust the managed policy to match your team's needs. See the [AWS documentation](/docs/aws/#tips-for-restricting-access) for examples of restricting access by email address or domain.

---

## Step 4 -- Configure each developer's CLI

Each developer runs one command to configure their AWS profile:

```bash
vouch setup aws --role arn:aws:iam::123456789012:role/VouchDeveloper
```

Replace the account ID with your own (printed in the CloudFormation stack outputs).

---

## Step 5 -- Log in and verify

```bash
vouch login
aws sts get-caller-identity --profile vouch
```

You should see your email address in the assumed role ARN:

```json
{
  "UserId": "AROA...:alice@yourcompany.com",
  "Account": "123456789012",
  "Arn": "arn:aws:sts::123456789012:assumed-role/VouchDeveloper/alice@yourcompany.com"
}
```

From here, `aws s3 ls --profile vouch`, `cdk deploy`, `terraform apply`, and any other AWS tool works with no additional setup.

---

## Step 6 -- Add more integrations

With the same `vouch login` session, configure the rest of your toolchain:

| Integration | Setup | Docs |
|---|---|---|
| SSH certificates | Automatic after login | [SSH](/docs/ssh/) |
| GitHub | `vouch setup github` | [GitHub](/docs/github/) |
| Docker (ECR) | `vouch setup docker` | [Docker](/docs/docker/) |
| CodeCommit | `vouch setup codecommit` | [CodeCommit](/docs/codecommit/) |
| CodeArtifact | `vouch setup codeartifact` | [CodeArtifact](/docs/codeartifact/) |
| EKS | `vouch setup eks` | [EKS](/docs/eks/) |

Each integration takes one command. After setup, every tool uses the same session -- one YubiKey tap covers the entire developer toolchain.

---

## What happens when someone leaves

This is where the investment pays off:

1. **Deactivate their Google Workspace account** (which you were going to do anyway).
2. **If SCIM is configured:** Vouch automatically revokes their active sessions. No manual steps needed. See [SCIM Provisioning](/docs/scim/) for setup.
3. **If SCIM is not configured:** Remove the user manually from the Vouch server. Their active session is revoked immediately.
4. **Outstanding credentials expire on their own** -- AWS STS credentials within 1 hour, SSH certificates within 8 hours.

There are no access keys to hunt down, no SSH keys to remove from servers, no GitHub PATs to revoke. The identity system you already manage (Google Workspace) is the single source of truth.

---

## Scaling up

As your team grows:

- **5--15 people:** Manual user management works fine. SCIM is optional.
- **15--50 people:** Set up [SCIM provisioning](/docs/scim/) to automate onboarding and offboarding with Google Workspace.
- **Multiple AWS accounts:** See [Multi-Account AWS Strategy](/docs/aws-multi-account/) for deploying the OIDC provider across dev/staging/prod accounts.
- **Compliance requirements:** See [Security](/docs/security/) for the full threat model and AWS Well-Architected alignment.


